/*********Circle Packing NOT NECESSARILY EQUAL *****/
/****************************************************************************
 * This Program takes as input
 *   1) graph name (graphName)
 *   2) graph definition (grph) Notes:
 *      -Can't use the name graph becasue that is used by NAUTY.
 *      -This is a vector of vectors. Where the ith vector is a sorted (from smallest to largest)
 *        vector of vertices adjacent to the ith vertex (0<= i < numberOfVertices)
 *      -The maximum degree of any vertex can be bigger than 6
 *      -The producted of factorial(degreee[i]-1) from i=0 to number of vertices must be
 *        less than 2^64. Otherwise there is an integer overflow
 *      -If there is a vertex with degree 2 then the graph is declared to be a multi-graph and the edge counting is 
 *       modified accordingly (i.e. degee two vertices are removed in the counting). In fact this is how this 
 *       program handles multi-graphs (i.e. those with loops and multi-edges). 
 *       If you want to determine all of the
 *       toroidal embeddings of a multi-graph replace each edge (multiedge AND regular edge) with a new vertex (a fake vertex) a two new edges
 *		 Make sure that if an added vertex has an index of fakeVertex, then
 *       all vertices with index bigger than are also fake vertices. 
 *   3) the number of its vertices (numberOfVertices) - this includes added vertices (i.e. fake vertices)
 *   4) the degree of each vertex stored in the vector degree.
 *  These inputs must be entered in the source file prior to compiling.
 *
 *  The output is
 *     1) A file, called graphName_Summary.txt, containing a list of all
 *        rotation schemes leading to inequivalent embeddings of
 *        this graph on a flat Torus. In this file it is noted for each vertex the
 *        degrees of the faces adjacent to it. **UPDATE LATER** It is also noted if
 *        the imbedding contains a forbidden face pattern (i.e. the graph
 *        cannot be the packing graph of any locally maximally dense packing.)
 *        It is sorted by face degree type. (A face degree type is a list of the degrees of
 *        all the faces in the emdedding.)
 *     2) A file, called graphName_Torus_Embeddings.txt containing a list of the inequivalent embeddings that **UPDATE LATER** do not contain
 *        a forbidden face pattern. The format is of the type that can be read by the
 *        program graphs and groups.
 *     **UPDATE LATER** 3) A file, called graphName_Torus_Embeddings_Forbidden.txt containing a list of the inequivalent embeddings that DO contain
 *        a forbidden face pattern. The format is a of the type that can be read by the
 *        program graphs and groups.
 *     4) A file, called graphName_Embedding_Names.txt, listing the names of all
 *        the inequivalent rotation schemes that lead to embeddings of the graph on the torus
 *        with out a forbidden face pattern. This will help in the assembly of
 *        a single postscript file containing commands (mostly generated by the graphs and groups program) to
 *        display all the possible inequivalent embeddings on the torus that do not contain a
 *        forbidden face pattern.
 *     **UPDATE LATER** 5) A file, called graphName_Embedding_Names_Forbidden.txt, listing the names of all
 *        the inequivalent rotation schemes that lead to embeddings of the graph on the torus
 *        with a forbidden face pattern. This will help in the assembly of
 *        a single postscript file containing commands (mostly generated by the graphs and groups program) to
 *        display all the possible inequivalent embeddings on the torus that do contain a
 *        forbidden face pattern.
 *
 *  Notes:
 *    This program uses NAUTY to calculate the automorphism group and needs to be linked with
 *    nauty.c, nautil.c, naugraph.c and naugroup.c.
 *
 ****************************************************************************/

#include <iostream>
#include <fstream>
#include <vector>
#include <algorithm>
//#include <omp.h>
using namespace std;

/*resizeToroidalRotationSchemeVector is an integer
 which when the number of possibly equivalent rotations scheme exceed this number
 the vector (toroidalRotationSchemes) is extend by another resizeToroidalRotationSchemeVector vectors*/
#define resizeToroidalRotationSchemeVector 10000

/*The next three lines are to enable the NAUTY program to run*/
#define MAXN 1000 /* Define this before including nauty.h */
#include "nauty.h" /* which includes <stdio.h> */
#include "naugroup.h" /* quotes means it searchs the local directory first then the system headers <> mean never search locally*/

/************************************************************************
 ***************Graph Details*********************************************
 * You have to manually change this information when you change the graph.
 *
 * Graph Details Include:
 *    1) The name of the graph being analyzed.This will also be used to create the output files
 *    2) Number of vertices of the graph 
 *    3) The graph being analyzed. Each list must be sorted from smallest to largest. The first vertex is number 0.
 *    4) The degree of each of the vertices in the graph. That is, degree[i] is
 *        the number vertices connected to vertex i. All degree two vertices
 *         must appear after the other vertices
 *************************************************************************/

/*THREE Vertices*/

/*     THREE Vertices - 5 Edges      */
//string graphName ="v3e05L01n01";
//# define numberOfVertices 9
//int grph[numberOfVertices][numberOfVertices-1] = {{3,4,5,6,7,8},{2,3,4},{1,5,6},{0,1},{0,1},{0,2},{0,2},{0,8},{0,7}};
//int degree[] = {6,3,3,2,2,2,2,2,2};

//string graphName ="v3e05L00n01";
//# define numberOfVertices 7
//int grph[numberOfVertices][numberOfVertices-1] = {{3,4,5,6},{2,3,4},{1,5,6},{0,1},{0,1},{0,2},{0,2}};
//int degree[] = {4,3,3,2,2,2,2};

//string graphName ="v3e06L01n01";
//# define numberOfVertices 10
//int grph[numberOfVertices][numberOfVertices-1] = {{3,4,5,6,7,8,9},{2,3,4,5},{1,6,7},{0,1},{0,1},{0,1},{0,2},{0,2},{0,9},{0,8}};
//int degree[] = {7,4,3,2,2,2,2,2,2,2};

//string graphName ="v3e06L00n01";
//# define numberOfVertices 8
//int grph[numberOfVertices][numberOfVertices-1] = {{3,4,5,6,7},{2,3,4,5},{1,6,7},{0,1},{0,1},{0,1},{0,2},{0,2}};
//int degree[] = {5,4,3,2,2,2,2,2};

//string graphName ="v3e07L01n01";
//# define numberOfVertices 11
//int grph[numberOfVertices][numberOfVertices-1] = {{3,4,5,6,7,8,9,10},{2,3,4,5},{1,6,7,8},{0,1},{0,1},{0,1},{0,2},{0,2},{0,2},{0,10},{0,9}};
//int degree[] = {8,4,4,2,2,2,2,2,2,2,2};

//string graphName ="v3e07L00n01";
//# define numberOfVertices 9
//int grph[numberOfVertices][numberOfVertices-1] = {{3,4,5,6,7,8},{2,3,4,5},{1,6,7,8},{0,1},{0,1},{0,1},{0,2},{0,2},{0,2}};
//int degree[] = {6,4,4,2,2,2,2,2,2};

//string graphName ="v3e06L01n02";
//# define numberOfVertices 11
//int grph[numberOfVertices][numberOfVertices-1] = {{3,4,5,6,7,8,9,10},{3,4,5},{6,7,8},{0,1},{0,1},{0,1},{0,2},{0,2},{0,2},{0,10},{0,9}};
//int degree[] = {8,3,3,2,2,2,2,2,2,2,2};

//string graphName ="v3e06L00n02";
//# define numberOfVertices 9
//int grph[numberOfVertices][numberOfVertices-1] = {{3,4,5,6,7,8},{3,4,5},{6,7,8},{0,1},{0,1},{0,1},{0,2},{0,2},{0,2}};
//int degree[] = {6,3,3,2,2,2,2,2,2};


/**************************************************************************/

/*****************Variables and methods to comute the ********************
 *****************The automorphism group of the graph*********************/
/*An automorphism of the graph is a permutation of length numberOfVertices*/
typedef vector<int> automorphism; //This can't be an array, because we use it inside of a vector later

/*The automorphism group will be generated by NAUTY and stored in a
 vector of automorphisms because we don't know how many elements it will have
 Initially this vector is empty, to add to it use .push_back to append an
 element at the end.*/
vector < automorphism > automorphismGroup;

/*This method is called by the NAUTY method allgroup.
 It just stores the permutation p in the automorphismGroup vector
 */
void storeautom(permutation *p, int n)
{
    int i;
    automorphism a;
    for (i = 0; i < n; ++i){
        a.push_back(p[i]);
    }
    automorphismGroup.push_back(a);
}
/**************************************************************************/

/* This method returns number! e.g. 5!=5*4*3*2*1 */
int factorial (int number)
{
    if  (number <= 1)
        return 1;
    return (number * factorial(number - 1));
}


/* This method takes a permutation and finds the inverse of it
 The inverse reverses the result of the permutation. i.e. inversePerm*perm[i] = I[i] = i for all i.
 So if perm causes v1->v2, then inversePerm causes v2->v1. Eg: if perm = [3,0,2,1] causes 0->3,
 1->0 and 3->1, then inversePerm = [1,3,2,0] because it causes 0->1, 1->3 and 3->0. */
vector < int > inverse(vector < int > perm)
{
    vector < int > inversePerm(numberOfVertices,-1);
    for(int i = 0; i < numberOfVertices; ++i)
        inversePerm[perm[i]] = i;
    return inversePerm;
}

///* 
// A method to sort determine if the rotation scheme v1 comes before v2 (return true) when
// sorted not by cartesian coordinates but by non-cartestian coordinates
//*/
//bool rotationSchemeSort (vector< vector <int> > v1, vector< vector <int> > v2){
//	
//	//Strategy convert to non-cartesian and then compare.
//	
//	//store the non-cartesian in the following two variables
//	vector< vector <int> > s1 (numberOfVertices,
//			vector < int > (numberOfVertices,-1) );
//	
//	vector< vector <int> > s2 (numberOfVertices,
//			vector < int > (numberOfVertices,-1) ); 
//	//translate v1 to non-carestian
//	for (int k=0; k < numberOfVertices; k++) {
//		//Find the first vertex that isn't mapped to itself in the kth vertex neighbors
//		int startVertex = 0;
//		for(int l = 0; l < numberOfVertices; ++l){
//			if (not(v1[k][l]==l)){
//				startVertex = l;
//				//break out of the l for loop
//				break;
//			}
//		}
//	
//		//record the startvertex as the first(i.e. zeroth) element of s1[k] because it is the smallest and we want to start with the smallest
//		s1[k][0]=v1[k][startVertex];
//		
//		// compute the next vertex in the rotation at vertex k (we know that this is not startVertex)
//		int nextVertex = v1[k][startVertex];
//
//		//trace the neighbors of vertex k, put them in the ith slot of the kth set of neighbors until we return to the start vertex
//		int i = 1;
//		
//		//we know that the first time through nextVertex and the startVertex are different, so this while loop will be entered
//		while (nextVertex!=startVertex) {
//			s1[k][i]=v1[k][nextVertex];
//			i++;
//			nextVertex = v1[k][nextVertex];
//		}
//	//end translate of v1 to non-cartesian
//	}
//	
//	//translate v2 to non-carestian
//	for (int k=0; k < numberOfVertices; k++) {
//		//Find the first vertex that isn't mapped to itself in the kth vertex neighbors
//		int startVertex = 0;
//		for(int l = 0; l < numberOfVertices; ++l){
//			if (not(v2[k][l]==l)){
//				startVertex = l;
//				//break out of the l for loop
//				break;
//			}
//		}
//		
//		//record the startvertex as the first(i.e. zeroth) element of s1[k] because it is the smallest and we want to start with the smallest
//		s1[k][0]=v2[k][startVertex];
//		
//		// compute the next vertex in the rotation at vertex k (we know that this is not startVertex)
//		int nextVertex = v2[k][startVertex];
//		
//		//trace the neighbors of vertex k, put them in the ith slot of the kth set of neighbors until we return to the start vertex
//		int i = 1;
//		
//		//we know that the first time through nextVertex and the startVertex are different, so this while loop will be entered
//		while (nextVertex!=startVertex) {
//			s1[k][i]=v2[k][nextVertex];
//			i++;
//			nextVertex = v2[k][nextVertex];
//		}
//		//end translate of v1 to non-cartesian
//	}
//	
//	//now compare s1 and s2 vertex by vertex
//	for (int k1=0; k1<numberOfVertices; k1++) {
//		for (int j1 =0; j1<numberOfVertices; j1++) {
//			if (s1[k1][j1]<s2[k1][j1]) {
//				return true;
//			}
//		}
//	}
//	return false;
//	
////end method	
//}

/******************************************************************
 * Here is where the main program starts
 ******************************************************************/
int main(int argc, char *argv[])
{
	
	/*********************************************************************
	 **********************************************************************
	 ********Determining the Toroidal rotation schemes*********************
	 **********************************************************************
	 **********************************************************************/
	
	//maxNumRotationsAtAnyVertex stores the maximum number of
	// rotations at any vertex. Recall that a rotation at a vertex i
	// is a cyclic permutation p_i:N(i) -> N(i) where N(i) are the
	// the neighbors of vertex i.
    // first find the maximum degree
    int maxDegree = 0;
    for(int i1 =0; i1 < numberOfVertices; i1++){
        if (maxDegree < degree[i1]){
            maxDegree=degree[i1];
        }
    }
    //the maximum number of rotations at any vertex is the factorial of maxDegree -1
    //   Minus one because in a cycle you can always choose the smallest element to be frist.
    int maxNumRotationsAtAnyVertex = factorial(maxDegree-1);
	
	// rotationChoiceList is an array that stores all rotations choices at each vertex.
	// For a vertex i, rotationChoiceList[i] is an array containing a list of
	// all the rotation choices at vertex i (each of which is a array)
	//
	// A choice of rotation at each vertex is a rotation scheme
	int rotationChoiceList[numberOfVertices][maxNumRotationsAtAnyVertex][numberOfVertices-1];
	
	/* Populate the rotationChoiceList which contains all the
	 possible rotation choices for each of the vertices. */
	for(int k = 0; k < numberOfVertices; ++k){
		//Start by copying the original (sorted) list of neighbors of vertex k into the rotationChoiceList in the zeroth slot.
		for(int temp=0; temp < degree[k]; ++temp){
			rotationChoiceList[k][0][temp] = grph[k][temp];
		};
		
		//Start at i=1 because i=0 is the original sorted nbhs
		int i = 1;
		
		//Calling the next_permutation method with argument grph[k]+1, grph[k]+degree[k]
		// start with the 2nd element (the first is always fixed as the smallest numbered neighboring vertex
		// advances grph[k] to the next element in the lexigraphically ordered permutations of the elements in
		// grph[k] from the 1st slot (not zeroth) to the degree[k] slot. It also returns true unless we are at the
		// end of the lexigraphic list (in which case it returns false and sets grph[k] back to the first item on the
		// lexigraphic list.
		while(next_permutation(grph[k]+1,grph[k]+degree[k])) {
			//Store the the next element of lexigraphic list in rotationChoiceList[k]
			for(int temp=0; temp < degree[k]; ++temp){
				rotationChoiceList[k][i][temp] = grph[k][temp];
			};
			i++;
		}
		
		//Print the RotationChoicsList
		//    printf("Vertex: %d",k);
		//    printf("\n");
		//    for(int ii=0; ii< maxNumRotationsAtAnyVertex; ++ii){
		//            for(int d =0; d < numberOfVertices-1; d++){
		//                printf(" %d",rotationChoiceList[k][ii][d]);
		//            }
		//        printf("\n");
		//    }
		//
		//    printf("Graph vertex: %d",k);
		//    printf("\n");
		//    for(int f=0; f< degree[k]; ++f){
		//        printf("%d ",grph[k][f]);
		//    };
		//    printf("\n");
		
	}
	
	// numberOfRotationChoices[k] is the number of rotation choices at vertex k
	int  numberOfRotationChoices[numberOfVertices];
	
	for(int i = 0; i < numberOfVertices; ++i){
		numberOfRotationChoices[i] = factorial(degree[i]-1);
	}
	// Convert rotationChoiceList to cartesian coordinatesand store them in
	//  rotationChoiceListCartesian.
	// This means that if rotationChoiceList[0][0]= [1,2,3]
	//  (that is it represents the cycle (0->0) (1->2->3->1) (4->4) then
	//  rotationChoiceListCartesian[0][0]= [0,2,3,1,4] so that
	//  rotationChoiceListCartesian[0][0][vertex]= image of vertex under
	//    cycle rotationChoiceList[0][0]
	int rotationChoiceListCartesian[numberOfVertices][maxNumRotationsAtAnyVertex][numberOfVertices];
	
	//Initialize rotationChoiceListCartesian so that all entries are their index, so that
	// after the next segement of code executes the right array appears.  This make it so that
	// issue with the image of a vertex that doesn't appear in the rotationChoiceList[i][j] is handled correctly -- like
	// vertex 4 above.
	for(int i = 0; i < numberOfVertices; ++i){
		for(int j = 0; j < numberOfRotationChoices[i]; ++j){
			for(int k = 0; k < numberOfVertices; ++k){
				rotationChoiceListCartesian[i][j][k] = k;
			}
		}
	}

	// Now set the rotationChoiceListCartesian to fill in the array appropriately
	for(int i = 0; i < numberOfVertices; ++i){
		for(int j = 0; j < numberOfRotationChoices[i]; ++j){
			for(int k = 0; k < degree[i]-1; ++k){
				rotationChoiceListCartesian[i][j][rotationChoiceList[i][j][k]] = rotationChoiceList[i][j][k+1];
			}
			rotationChoiceListCartesian[i][j][rotationChoiceList[i][j][degree[i]-1]] = rotationChoiceList[i][j][0];
		}
	}
	
	////print the rotationChoiceListCartesian
	//for(int i = 0; i < numberOfVertices; ++i){
	//    printf("Vertex %d: ",i);
	//    for(int j = 0; j < numberOfRotationChoices[i]; ++j){
	//        for(int k = 0; k < numberOfVertices; ++k){
	//            printf("%d ",rotationChoiceListCartesian[i][j][k]);
	//        };
	//        printf("\n");
	//    }
	//}
	
	//Find number of rotation schemes. This is the maximum index of our
	// main loop. Store this in numberOfRotationSchemes.
	// numberOfRotationSchemes = product of all numberOfRotationChoices[i]
	// We need this to be less than 2^64.
	int64_t numberOfRotationSchemes = 1;
	for(int i = 0; i < numberOfVertices;++i){
		numberOfRotationSchemes *= numberOfRotationChoices[i];
	}
	cout << numberOfRotationSchemes << "\n";
	
	/* numberOfEdges stores the number of edges of our graph grph
	 by summing up the degrees and then dividing by 2 because of
	 double counting */
	int numberOfEdges = 0;
	for(int i = 0; i < numberOfVertices; ++i)
		numberOfEdges += degree[i];
	numberOfEdges = numberOfEdges/2;
	
	// numberOfFaces stores the number of faces in a toridal embedding of our graph.
	// It is calculated from Euler formula on a torus (V-E+F=0 = 2-2*1)
	int numberOfFaces = numberOfEdges-numberOfVertices;
	
	// Assign ponter to the first element of the rotationChoiceListCartesian
	// This pointer will help us avoid problem of writing down numberOfVertices nested loops
	int *pointer = &rotationChoiceListCartesian[0][0][0];
	
	// currentRotationScheme stores the current rotation scheme in the main loop below.
	int currentRotationScheme[numberOfVertices][numberOfVertices];
	
	//Initialize currentRotationScheme to the zeroth choice for each vertex in rotationChoiceListCartesian
	for(int i = 0; i < numberOfVertices;++i){
		for(int j=0; j< numberOfVertices; ++j){
			currentRotationScheme[i][j] = rotationChoiceListCartesian[i][0][j];
		}
	}
	
	/* Create the currentRotationSchemeIndexList that contains the list of indices of the
	 rotation choice at each vertex. This is list that is going to be
	 used in the main loop of our program */
	int currentRotationSchemeIndexList[numberOfVertices];
	
	/* Store the good (i.e. Toroidal) currentRotationScheme after the face walking while loop
	 into toroidalRotationSchemes's equivalence.
	 A rotation scheme is "good" iff it is embedable on the torus.
	 the constant resizeToroidalRotationSchemeVector is used instead of numberOfRotationSchemes due
	 to the very big value of numberOfRotationSchemes. A vector is used because we don't
	 know how many toroidalRotationScheme there are*/
	vector < vector < vector < int >  > > toroidalRotationSchemes (resizeToroidalRotationSchemeVector,
			 vector < vector < int >  > (numberOfVertices,
					  vector < int > (numberOfVertices,-1)));
	
	//Keep track of the number of ToroidalRotationScheme stored
	int numToroidalRotationSchemes = 0;
	
	//Store the graph into an adjacency matrix grphAdjMatrix.
	int grphAdjMatrix[numberOfVertices][numberOfVertices];
	//initialize the matrix
	//first set it equal to zero
	for(int i = 0; i < numberOfVertices; ++i){
		for(int j = 0; j < numberOfVertices; ++j){
			grphAdjMatrix[i][j] = 0;
		}
	}
	//Second fill in the edges
	for(int i = 0; i < numberOfVertices; ++i){
		for(int j = 0; j < degree[i]; ++j){
            grphAdjMatrix[i][grph[i][j]] = 1;
		}
	}
	
	/* This is going to be the current edge in the loop
	 starting at vertex currentEdge[0] and ending at vertex currentEdge[1]
	 currentEdge[2] is just a dummy variable that is going to help us
	 with the while statement within the main loop later on.
	 currentEdge[2] is just temp storage for currentEdge[1] */
	int currentEdge[]= {-1,-1,-1};
	
	// numOfFacesWalked stores number of faces walked.
	// It shouldn't exceed numberOfFaces at any time.
	int numOfFacesWalked = 0;
	
	
	//tempNumberOfEdges records the number of faces in the current face.
	int tempNumberOfEdges = 0;
	
	// //Print the adjacency matrix grphAdjMatrix.
	//for(int i = 0; i < numberOfVertices; ++i){
	//    for(int j = 0; j < numberOfVertices; ++j){
	//        printf(" %2d",grphAdjMatrix[i][j]);
	//    }
	//    printf("\n");
	//}
	//printf("\n");
	
	//A 64 bit integer used to set the currentRotationSchemeIndexList
	int64_t prod = 1;
	
	/* Remember that grphAdjMatrix is our adjecency matrix for
	 any currentRotationScheme. So, we set the mutatable matrix tempGrphAdjMatrix
	 equal to grphAdjMatrix. After that, we're going to search for a 1
	 in tempGrphAdjMatrix and then faceWalk until we don't have any more 1's in it. */
	int tempGrphAdjMatrix[numberOfVertices][numberOfVertices];
	
	/**********************************************************************
	 * This is the main loop where we consider each rotation scheme and test
	 * it with a facewalk. If it passes, we store it otherwise discard it.
	 **********************************************************************/
	
	//#if defined(USE_OPENMP)
	//#pragma omp parallel for shared(toroidalRotationSchemes,numToroidalRotationSchemes,\
	//maxNumRotationsAtAnyVertex,numberOfRotationChoices,pointer,grphAdjMatrix,numberOfFaces)\
	//private(prod,k,currentRotationSchemeIndexList,currentRotationScheme,i,j,tempGrphAdjMatrix,numOfFacesWalked,\
	//currentEdge)
	//#pragma omp parallel for default(shared) private(prod,currentRotationSchemeIndexList,currentRotationScheme,\
	//tempGrphAdjMatrix,numOfFacesWalked,currentEdge,k,j1,k1,j2,k2,j3,k3,i1,j)
	//#endif
	//#pragma omp for private(prod,k,currentRotationSchemeIndexList,currentRotationScheme,i,j,tempGrphAdjMatrix,numOfFacesWalked, currentEdge,numOfFacesWalked) shared(numberOfVertices,toroidalRotationSchemes,numToroidalRotationSchemes, maxNumRotationsAtAnyVertex,numberOfRotationChoices,pointer,grphAdjMatrix,numberOfFaces)
	//#pragma omp for private(prod,currentRotationSchemeIndexList,currentRotationScheme,tempGrphAdjMatrix,numOfFacesWalked, currentEdge,numOfFacesWalked) shared(numberOfVertices,toroidalRotationSchemes,numToroidalRotationSchemes, maxNumRotationsAtAnyVertex,numberOfRotationChoices,pointer,grphAdjMatrix,numberOfFaces)

	
#pragma omp parallel shared(toroidalRotationSchemes,numToroidalRotationSchemes,maxNumRotationsAtAnyVertex,numberOfRotationChoices,pointer,grphAdjMatrix,numberOfFaces) private(prod,currentRotationSchemeIndexList,currentRotationScheme,tempGrphAdjMatrix,numOfFacesWalked,currentEdge,tempNumberOfEdges)
	{
#pragma omp for
		for(int64_t i = 0; i < numberOfRotationSchemes;++i){
            if (i%100000000==0) {
                cout << "100000000 down" << endl;
            }
			// Finds the current currentRotationSchemeIndexList in a PARALLELIZABLE way!
			//  That is, given an index i this sets the indices in the currentRotationSchemeIndexList
			//  so that they correspond to the ith rotation scheme VERY COOL!!!
			// First reset prod
			prod = 1;
			for(int k1 = 0; k1 < numberOfVertices; ++k1){
				currentRotationSchemeIndexList[k1] = (i/prod)%numberOfRotationChoices[k1];
				prod *= numberOfRotationChoices[k1];
			}
			
			// Create the current rotation scheme using the current currentRotationSchemeIndexList
			// and pointer arithmetic.  Recall that the pointer pointer points to the first element in the
			// rotationChoiceList. RotationChoiceList is a numberVertices by maxNumRoationsAtAnyVerex array.
			//  This very cleverly uses the indices in currentRotationSchemeIndexList to set the currentRotationScheme
			for(int j1 = 0; j1 < numberOfVertices;++j1){
				for(int k2 = 0; k2 < numberOfVertices; ++k2){
					currentRotationScheme[j1][k2] = pointer[j1*numberOfVertices*maxNumRotationsAtAnyVertex +
															numberOfVertices*currentRotationSchemeIndexList[j1] + k2];
				}
			}
			
			// set tempGrphAdjMatrix to grphAdjMatrix adjecency
			for(int i1 = 0; i1 < numberOfVertices; ++i1){
				for(int j2 = 0; j2 < numberOfVertices; ++j2){
					tempGrphAdjMatrix[i1][j2] = grphAdjMatrix[i1][j2];
				}
			}
			//reset the number of faces walked
			numOfFacesWalked = 0;
			
			//reset tempNumberOfEdges 
			tempNumberOfEdges = 0;

			
			/******************************************************************
			 * This is the infamous facewalking algorithem. We consider the
			 * current rotation scheme currentRotationScheme and start creating all its faces.
			 * If they exeed numberOfFaces, we discard it. To ensure this, we use the
			 * adjecency matrix tempGrphAdjMatrix that starts out as grphAdjMatrix, but then as we use an
			 * edge during our facewalk, we increase its respective coordinate
			 * in tempGrphAdjMatrix by one. tempGrphAdjMatrix is going to have only 0's, 1's and 2's. To create
			 * the next face, we look for remaining 1's. if there's none we're
			 * done with this loop (tempGrphAdjMatrix has only 0's and 2's) and check if we have
			 * reached the numOfFacesWalked == numberOfFaces. In case there's still 1s remaining, but we
			 * already reached numberOfFaces, we discard that rotation scheme.
			 *******************************************************************/
			for(int j = 0; j < numberOfVertices; ++j){
				for(int k = 0; k < numberOfVertices; ++k){
					if(tempGrphAdjMatrix[j][k] == 1){
						if(numOfFacesWalked == numberOfFaces){
							goto outer; //discard the current rotation scheme, because this means there
						// is at least one more face, so there are too many faces determined by the
						// currentRotationScheme
					    } else {
							// set current egde to the one for which tempGrphAdjMatrix[j][k] == 1
							currentEdge[0] = j;
							currentEdge[1] = k;
							currentEdge[2] = -1; //force the while loop to execute at least once
							// while current edge is not equal to one for which tempGrphAdjMatrix[j][k]==1
							while(currentEdge[2] != j || currentEdge[1] != k){
								// currentEdge[2] is just temp storage for currentEdge[1]
								currentEdge[2] = currentEdge[1];
								//Here we are using the fact that the next edge in after <j,k> is <k,p_k(j)>
								// where p is the current rotation scheme (j=currentEdge[0], k=currentEdge[1])
								// notice how nice the cartesian coordinates are to use (NO Methods Called!)
								currentEdge[1] = currentRotationScheme[currentEdge[1]][currentEdge[0]];
								currentEdge[0] = currentEdge[2];
								tempGrphAdjMatrix[currentEdge[0]][currentEdge[1]]++; //mark the edge as used
								// if the currentEdge[0] is NOT a degree 2 vertex increase tempEdges by one
								if(degree[currentEdge[0]] > 2){
										  tempNumberOfEdges++;
									      //cout<< tempNumberOfEdges << "in ";
                                };
								//cout<< tempNumberOfEdges << "out ";
							}// finished walking a face
							//cout << numOfFacesWalked << " num faces walked so far " << "\n";
							// if the face is a 1 or 2 gon then discard this rotation scheme because it is an attemp
							// to embed a digon or or unigon
							if(tempNumberOfEdges<3){
								//cout << "went to outer \n";
								goto outer;
                            };
							
							// increase the number of faces walked by 1
							numOfFacesWalked++;
							
							//reset the number of edges in the current face
							tempNumberOfEdges=0;
						}
					}
				}
			}
			
			/* This is where we check if we are short of faces once finished
			 the loop. If we have the exact number of faces we store that rotation
			 scheme into toroidalRotationSchemes and increase the number of Toroidal rotation schemes counter. */
			if (numOfFacesWalked == numberOfFaces) {
#pragma omp critical
				{
					//If the number of toroidal rotation schemes (numToroidalRotationSchemes)
					//  more then the initial allocation of resizeToroidalRotationSchemeVector
					//  then we need to resize the vector toroidalRotationSchemes
					//  this should resize the toroidalRotationScheme vector every resizeToroidalRotationSchemeVector schemes
					if (numToroidalRotationSchemes > 0 && numToroidalRotationSchemes%resizeToroidalRotationSchemeVector==0){
						toroidalRotationSchemes.resize((numToroidalRotationSchemes/resizeToroidalRotationSchemeVector+1)*resizeToroidalRotationSchemeVector,
													   vector < vector < int >  > (numberOfVertices,
																vector < int > (numberOfVertices,-1)) );
					}
					
					for(int j3 = 0; j3 < numberOfVertices;++j3){
						for(int k3 = 0; k3 < numberOfVertices; ++k3){
							toroidalRotationSchemes[numToroidalRotationSchemes][j3][k3] = currentRotationScheme[j3][k3];
						}
					}
					numToroidalRotationSchemes++;
				} // end the critical open mp section
			}
			
			// This is where we end up if the current currentRotationScheme doesn't embed on the torus.
		outer:;
			
			//end Main loop
		}
		//end pragma parallel scope
	}
	
	
//	 //Print the rotation schemes in toroidalRotationSchemes
//	    for(int j = 0; j < numToroidalRotationSchemes;++j){
//	        for(int k = 0; k < numberOfVertices; ++k){
//	            cout << "{ ";
//	            for(int l = 0; l < numberOfVertices; ++l)
//	                cout << toroidalRotationSchemes[j][k][l] << " ";
//	            cout << "} ";
//	        }
//	        cout << endl;
//	
//	    }
//	cout << endl;
	cout << numToroidalRotationSchemes << endl;
	
	/*********************************************************************
	 **********************************************************************
	 ********End of determining the Toroidal rotation schemes**************
	 **********************************************************************
	 **********************************************************************/
	
	cout << "Determined Toroidal Rotation Schemes Now Sort them" << endl;

		/***************************************************************************
		 ****************************************************************************
		 *****From the Toroidal embeddings sort them into differentfaceTypes.********
		 ****************************************************************************
		 ***************************************************************************/
		//Determine if the graph is a multigraph and set the value of multigraph
		//If it is a multigraph set the value of the fakeVertex. That is the vertices with
		//  INDICES fakeVertex, fakeVertex+1, fakeVertex +2,..., numberOfVertices-1 have been
		//  added to account for loops and multi-edges
		bool multiGraph = false; //start by assuming that the graph is not a multigraph
	    int fakeVertex = numberOfVertices + 1; //start by assuming that there are no multiedges or loops 
	    for(int j=0; j < numberOfVertices; ++j){
			if (degree[j]==2) {
				multiGraph = true;
				fakeVertex = j;
				break;
			};
		};
	
	    // estimate the maximum number of face types
	    int maxNumFaceTypes = 100;
	
	    //multiGraphs tend to have A LOT more face types
	    if (multiGraph) {
            maxNumFaceTypes = maxNumFaceTypes*maxNumFaceTypes;
        };
	
		
		// faceTypes stores the number of edges in each face (face Degree) of
		// the current Toroidal rotation scheme into a vector .
		// it is index is incremented when a new face type is encountered
		// Only faceTypes[0], faceTypes[1],...,faceTypes[faceTypeCount-1] are meaningful
		//  faceTypes[faceTypeCount] is a dummy vector that is used to store the current number of edges
		//  in each face of the current Toroidal rotation scheme, it is then sorted and tested to see
		//  if it matches any of the existing faceTypes.
		
		vector < vector < int > > faceTypes(maxNumFaceTypes,
				 vector < int > (numberOfFaces,0));
		
		// Stores the number of different face types
		int faceTypeCount = 0;
		
		
		// Sort the Toroidal rotation schemes by their faceType
		// sortedToroidalRotationSchemes[ face type number ] [number of schemes of that face type] [vertex] [vertex]
		// This is still cartesian
		// start with 1 vector of this type, because we build sortedToroidalRotationScheme via insertion
		vector < vector < vector < vector < int > > > > sortedToroidalRotationSchemes (1,
				 vector < vector < vector < int > > > (toroidalRotationSchemes.size(),
						  vector < vector < int > > (numberOfVertices,
								   vector < int > (numberOfVertices,-1))));
		
		//Sort the rotations schemes lexigraphically by face type in the sortedToroidalRotationSchemes
		// to do this we must insert the new faces types in a position (called insertPosition) in sortedToroidalRotationSchemes
		// Create the insert position variable and initialize it to zero
		int insertPosition = 0;
		
		
		// Contains the number of rotation schemes for each faceType.
		//  initiallized at zero
		vector < int > numRotSchInFaceTypes(maxNumFaceTypes,0);
		
		for(int i = 0; i < numToroidalRotationSchemes;++i){
			
			// reset tempGrphAdjMatrix to grphAdjMatrix adjecency
			for(int i1 = 0; i1 < numberOfVertices; ++i1){
				for(int j1 = 0; j1 < numberOfVertices; ++j1){
					tempGrphAdjMatrix[i1][j1] = grphAdjMatrix[i1][j1];
				}
			}
			
			// reset tempNumberOfEdges -- the number of edges in the current face.
			tempNumberOfEdges = 0;
			
			//reset the number of faces walked
			numOfFacesWalked = 0;
			
			for(int j = 0; j < numberOfVertices; ++j){
				for(int k = 0; k < numberOfVertices; ++k){
					if(tempGrphAdjMatrix[j][k] == 1){
						// set current edge to the one for which tempGrphAdjMatrix[j][k] == 1
						currentEdge[0] = j;
						currentEdge[1] = k;
						currentEdge[2] = -1; //force the while loop to execute at least once
						// while current edge is not equal to one for which tempGrphAdjMatrix[j][k]==1
						while(currentEdge[2] != j || currentEdge[1] != k){
							// currentEdge[2] is just temp storage for currentEdge[1]
							currentEdge[2] = currentEdge[1];
							//Here we are using the fact that the next edge in after <j,k> is <k,p_k(j)>
							// where p is the current rotation scheme (j=currentEdge[0], k=currentEdge[1])
							// notice how nice the cartesian coordinates are to use (NO Methods Called!)
							currentEdge[1] = toroidalRotationSchemes[i][currentEdge[1]][currentEdge[0]];
							currentEdge[0] = currentEdge[2];
							tempGrphAdjMatrix[currentEdge[0]][currentEdge[1]]++; //mark the edge as used
							//if the currentEdge[0] is NOT a degree 2 vertex then increase the number of edges traced/walked
							if(degree[currentEdge[0]] > 2){
									  tempNumberOfEdges++;
							};
						}// finished walking a face
						
						// Store the number of currentEdges of the current face.
						faceTypes[faceTypeCount][numOfFacesWalked] = tempNumberOfEdges;
						// increase the number of faces walked by 1
						numOfFacesWalked++;
						//reset the number of Edges in the current face			  
						tempNumberOfEdges = 0;
					}
				}
			}
			
			//first sort the faceTypes vector
			sort(faceTypes[faceTypeCount].begin(), faceTypes[faceTypeCount].end());
			
			//Update insertPosition so that if we have a new face type it is inserted at the start of the vector unless it is found
			// to be lexigraphically after one of the exisiting faceTypes
			insertPosition =  0;
			
			//start by assuming a new face type has been encountered
			boolean newFaceType = true;
			//loop through all the known face types (to see if this face type has been encountered before)
			for(int j = 0; j < faceTypeCount;++j){
				//assume that the face type under consideration is new and start to update the insertPosition integer
				// if the face type under consideration, faceTypes[faceTypeCount], occurs lexigraphically after the
				// the face type in slot j (faceTypes[j]) then update insertPosition to j+1
				
				for(int j1=0; j1 < numberOfFaces; ++j1){
					if (faceTypes[j][j1] < faceTypes[faceTypeCount][j1]) {
						insertPosition = j+1;
						break;
					}
					// if faceTyes[j][j1] is equal to faceTypes[faceTypeCount][j1] then proceed to compare the next digit in the array
					//  if they are not equal then don't proceed to compare the next digit
					if (faceTypes[j][j1] != faceTypes[faceTypeCount][j1]) { break;}
				}
				
				//check to see if the current facetype has been encountered before (faceTypes[faceTypeCount] holds the face type under consideration)
				if(faceTypes[j] == faceTypes[faceTypeCount]){
					
					// this face type is not new, so record this rotation scheme in face type index j, and it is
					//  the numRotSchInFaceType[j]'th of these facetype seen before.
					for(int j1 = 0; j1 < numberOfVertices;++j1){
						for(int k1 = 0; k1 < numberOfVertices; ++k1){
							sortedToroidalRotationSchemes[j][numRotSchInFaceTypes[j]][j1][k1] = toroidalRotationSchemes[i][j1][k1];
						}
					}
					//increment numRotSchInFaceTypes[j]
					numRotSchInFaceTypes[j]++;
					//This is not a new face type
					newFaceType = false;
					break;
				}
			}
									  
									  
			//If this is a newFaceType then record the rotationScheme in face type index faceTypeCount and it is
			//  the numberRotSchInFaceType[faceTypeCount]=0 of this type
			if(newFaceType){
				//Sort the rotations schemes lexigraphically by face type in the sortedToroidalRotationSchemes so insert the new type in
				//  position insertPosition (which was set above)
				// first  create a temp vector of the correct type to insert
				vector < vector < vector < int > > > tempVector(toroidalRotationSchemes.size(),
						 vector < vector < int > > (numberOfVertices,
								 vector < int > (numberOfVertices,-1)));
				//Next create a new slot and insert the tempVector
				sortedToroidalRotationSchemes.insert(sortedToroidalRotationSchemes.begin()+insertPosition,tempVector);
				
				//Insert a one in the correct slot (insertPosition) in numberRotSchInFaceType to indicate that one of this new type is recorded
				numRotSchInFaceTypes.insert(numRotSchInFaceTypes.begin()+insertPosition,1);
				
				//Put the new face type pattern in the correct location in the faceTypes Vector
				faceTypes.insert(faceTypes.begin()+insertPosition,faceTypes[faceTypeCount]);
				
				//Copy the toroidalRotationScheme into the correct slot in sortToroidalRotationScheme vector
				for(int j1 = 0; j1 < numberOfVertices;++j1){
					for(int k1 = 0; k1 < numberOfVertices; ++k1){
						// the 0 is used because this is the first (zeroth slot) rotationScheme of this face type
						sortedToroidalRotationSchemes[insertPosition][0][j1][k1] = toroidalRotationSchemes[i][j1][k1];
					}
				}
				
				//increment faceTypeCount so that in the next interation of the loop, we won't overwrite an existing type.
				faceTypeCount++;
			}
		}// end the for loop going through all the rotation schemes
		
		//For each face type sort the rotation schemes lexigraphically
		for (int i =0; i < faceTypeCount ; ++i){
			 sort(sortedToroidalRotationSchemes[i].begin(), sortedToroidalRotationSchemes[i].begin()+numRotSchInFaceTypes[i]);  
			// sort(sortedToroidalRotationSchemes[i].begin(), sortedToroidalRotationSchemes[i].begin()+numRotSchInFaceTypes[i],rotationSchemeSort);
		}
		
//		 //print data and the rotation schemes (in cartesian form) by sorted face type
//		cout << "The number of toroidal rotation schemes is " << numToroidalRotationSchemes << endl;
//		cout << "The number of different faceTypes are: " << faceTypeCount << endl;
//		cout << endl;
//		for(int i=0;i<faceTypeCount;++i){
//			cout << endl;
//			cout << "Face Count Type " << i << " [ ";
//			for(int j=0;j<numberOfFaces;++j){
//				cout << faceTypes[i][j] << " ";
//			};
//			cout<< "] " << " There are " << numRotSchInFaceTypes[i] << " rotation schemes in this type." << endl;
//			for(int j=0;j< numRotSchInFaceTypes[i]; ++j){
//				for(int k = 0; k < numberOfVertices; ++k){
//					cout << "{ ";
//					for(int l = 0; l < numberOfVertices; ++l){
//						cout << sortedToroidalRotationSchemes[i][j][k][l] << " ";
//					}
//					cout << "} ";
//				}
//				cout << endl;
//			}
//		}
		
		
		
		/***************************************************************************
		 ****************************************************************************
		 *****End of sorting the torus embedding into  different face types**********
		 ****************************************************************************
		 ***************************************************************************/
		cout << "Start Using Nauty" << endl;
		/******************************************************************
		 *******************************************************************
		 ****************Start using Nauty. ********************************
		 ********* Compute automorphism group ******************************
		 *******************************************************************
		 ******************************************************************/
		graph g[MAXN*MAXM];
		int lab[MAXN],ptn[MAXN],orbits[MAXN];
		static DEFAULTOPTIONS_GRAPH(options);
		statsblk stats;
		setword workspace[5*MAXM];
		
		int m,v,k;
		set *gv;
		
		/* The nauty parameter m is a value such that an array of
		 * m setwords is sufficient to hold n bits. The type setword
		 * is defined in nauty.h. The number of bits in a setword is
		 * WORDSIZE, which is 16, 32 or 64. Here we calculate
		 * m = ceiling(n/WORDSIZE). */
		m = (numberOfVertices + WORDSIZE - 1) / WORDSIZE;
		
		/* The following optional call verifies that we are linking
		 * to compatible versions of the nauty routines. */
		nauty_check(WORDSIZE,m,numberOfVertices,NAUTYVERSIONID);
		
		/* Default options are set by the DEFAULTOPTIONS_GRAPH macro above.
		 * Here we change those options that we want to be different from the
		 * defaults. writeautoms=False causes automorphisms to not be written. */
		options.writeautoms = FALSE;
		
		/* Now we change the graph to NAUTY notation
		 * gv is a row, so first a row is created
		 * EMPTYSET zeros the rwo,
		 * then ADDELEMENT adds one bit (a directed edge) to it */
		for(v = 0; v < numberOfVertices; ++v){
			gv = GRAPHROW(g,v,m);
			EMPTYSET(gv,m);
			for (k = 0; k < degree[v]; ++k){
				ADDELEMENT(gv,grph[v][k]);
			}
		}
		
		// The following cause nauty to call two procedures which
		//store the group information as nauty runs. */
		grouprec *group;
		options.userautomproc = groupautomproc;
		options.userlevelproc = grouplevelproc;
		
		nauty(g,lab,ptn,NULL,orbits,&options,&stats,
			  workspace,5*m,m,numberOfVertices,NULL);
		/* Get a pointer to the structure in which the group information
		 has been stored. If you use TRUE as an argument, the
		 structure will be "cut loose" so that it won't be used
		 again the next time nauty() is called. Otherwise, as
		 here, the same structure is used repeatedly. */
		group = groupptr(FALSE);
		
		/* Expand the group structure to include a full set of coset
		 representatives at every level. This step is necessary
		 if allgroup() is to be called. */
		makecosetreps(group);
		
		/* Call the procedure storeautom() for every element of the group.
		 The first call is always for the identity. */
		allgroup(group,storeautom);
		
		//int l,ik;
		//for(l=0; l<automorphismGroup.size(); ++l){
		//   for(ik=0; ik < numberOfVertices; ++ik){
		//    printf("%d ", automorphismGroup[l][ik]);
		//   }
		//   printf("\n");
		//}
		//printf("autosize %d ",automorphismGroup.size());
		
		/******************************************************************
		 *******************************************************************
		 ********This is where we're done using Nauty. *********************
		 ********* Computation of the automorphism group is complete.*******
		 *******************************************************************
		 ******************************************************************/
		
		/***************************************************************************
		 ****************************************************************************
		 *****Determine the inequivalent embeddings**********************************
		 * two rotation schemes, r & p are equivalent if there exists a in **********
		 **Aut(G) such that *********************************************************
		 ***1)  a r_i a^(-1) = p_(a(i)) for all i (just different labeling) *********
		 ***2)  a r_i^(-1) a^(-1) = p_(a(i)) for all i (just different orientations)*
		 ****************************************************************************
		 ***************************************************************************/
		
		/* Create a vector of vectors that stores each final index in sortedToroidalRotationSchemes
		 By final index is meant the index of each of the representatives
		 of an equivalence class within a faceType. */
		vector < vector < int > > indexOfInqInSortedToroidalRotationSchemes(faceTypeCount,
				 vector < int > (toroidalRotationSchemes.size(),0));
		
		// Stores the number of inequivalet Embeddings in a
		// certain FaceType.
		//int numIneqEmbInFaceType[faceTypeCount];
		vector < int > numIneqEmbInFaceType (faceTypeCount, 0);
		
		// Stores the inverse of the current rotation scheme.
		//int inverseCurrentRotationScheme[numberOfVertices][numberOfVertices];
		vector < vector < int > > inverseCurrentRotationScheme(numberOfVertices,
				 vector < int > (numberOfVertices, -1));
		
		// Stores the current automorphism group element.
		//int alpha[numberOfVertices];
		vector < int > alpha(numberOfVertices,-1);
		
		// Stores the inverse of the current automorphism
		// group element so that (alpha)o(invAlpha) = I
		//int invAlpha[numberOfVertices];
		vector < int > invAlpha(numberOfVertices,-1);
		
		// Stores the current equivalent rotation scheme to the
		// current rotation scheme generated by alpha:
		// conjCurrentRotationScheme[i] = (alpha)o(currentRotationScheme[k])(invAlpha)[i];
		vector < vector < int > > conjCurrentRotationScheme(numberOfVertices,
															vector < int > (numberOfVertices, -1));
		
		// Stores the inverse of conjCurrentRotationScheme: inverseConjugateCurrentRotationScheme[i] =
		// (alpha)o(inverseCurrentRotationScheme[k])(invAlpha)[i];
		vector < vector < int > > inverseConjugateCurrentRotationScheme(numberOfVertices,
																		vector < int > (numberOfVertices, -1));
		
		/***************************************************************
		 * This loop stores only one representative for each
		 * equivalent class generated by the automorphism group
		 * applied on sortedToroidalRotationSchemes.
		 ****************************************************************/
		
		//search through each faceType
		for(int faceTypeIndex = 0; faceTypeIndex < faceTypeCount; ++faceTypeIndex){
			//search through the number of rotation schemes in each face type
			for(int rotationSchemeInFaceTypeIndex = 0;
				rotationSchemeInFaceTypeIndex < numRotSchInFaceTypes[faceTypeIndex];
				++rotationSchemeInFaceTypeIndex){
				
				//Why -1? Because when an rotation scheme is found to be equivalent to the current one (either inverse or conjugate or both) it is marked by
				//  turning the [0][0] element of it to -1
				if(sortedToroidalRotationSchemes[faceTypeIndex][rotationSchemeInFaceTypeIndex][0][0] != -1){
					
					// Store the current rotation scheme's index because this is either the first one in its face type
					//  or it is an unmarked rotation scheme and because we are searching sequentially through the
					//  rotation schemes, it is not equivalent to any of the previous ones and therefore should be stored
					//  as a representative of its equivalence class.
					indexOfInqInSortedToroidalRotationSchemes[faceTypeIndex][numIneqEmbInFaceType[faceTypeIndex]] = rotationSchemeInFaceTypeIndex;
					
					// Update the number of inequivalent embeddings in our faceType
					numIneqEmbInFaceType[faceTypeIndex]++;
					
					// Compute inverse of the current rotation scheme
					for(k = 0; k < numberOfVertices; ++k){
						inverseCurrentRotationScheme[k] = inverse(sortedToroidalRotationSchemes[faceTypeIndex][rotationSchemeInFaceTypeIndex][k]);
					}
					
					// Mark the rotation scheme that is equal to inverseCurrentRotationScheme
					for(k = rotationSchemeInFaceTypeIndex + 1; k < numRotSchInFaceTypes[faceTypeIndex]; ++k){
						if(inverseCurrentRotationScheme == sortedToroidalRotationSchemes[faceTypeIndex][k]){
							sortedToroidalRotationSchemes[faceTypeIndex][k][0][0] = -1;
							break;
						}
					}
					
					//Use each element of the automorphism Group to conjugate the
					// current rotation scheme or the inverse of the current rotation scheme
					// mark those that are equal to the conj or conj of inverse.
					// start at j=1, because j=0 is in the identity element in the automorphism group
					for(unsigned int j = 1; j < automorphismGroup.size(); ++j){
						
						// Assign alpha to the first automorphismGroup and compute the
						// inverse of the current rotation scheme.
						for(int k = 0; k < numberOfVertices; ++k){
							alpha[k] = automorphismGroup[j][k];
						}
						
						// invAlpha stores the inverse of alpha
						invAlpha = inverse(alpha);
						
						// Compute the current conjCurrentRotationScheme, inverseConjugateCurrentRotationScheme
						for(int k = 0; k < numberOfVertices; ++k){
							for(int l = 0; l < numberOfVertices; ++l){
								conjCurrentRotationScheme[alpha[k]][l] = alpha[sortedToroidalRotationSchemes[faceTypeIndex][rotationSchemeInFaceTypeIndex][k][invAlpha[l]]];
								inverseConjugateCurrentRotationScheme[alpha[k]][l] = alpha[inverseCurrentRotationScheme[k][invAlpha[l]]];
							}
						}
						
						// Mark the rotation scheme that is equal to conjCurrentRotationScheme
						for(int k = rotationSchemeInFaceTypeIndex + 1; k < numRotSchInFaceTypes[faceTypeIndex]; ++k){
							if(conjCurrentRotationScheme == sortedToroidalRotationSchemes[faceTypeIndex][k]){
								sortedToroidalRotationSchemes[faceTypeIndex][k][0][0] = -1;
								break;
							}
						}
						
						// check to see if conjCurrentRotationScheme == inverseConjugateCurrentRotationScheme
						// If these are equal to each other then there is no need to check the remaining
						// rotation schemes in this Face type for the inverse of the conjugate, because it
						// will have been marked already.
						if(!(conjCurrentRotationScheme == inverseConjugateCurrentRotationScheme)){
							for(int k = rotationSchemeInFaceTypeIndex + 1; k < numRotSchInFaceTypes[faceTypeIndex]; ++k){
								if(inverseConjugateCurrentRotationScheme == sortedToroidalRotationSchemes[faceTypeIndex][k]){
									sortedToroidalRotationSchemes[faceTypeIndex][k][0][0] = -1;
									break;
								}
							}
						}
					}
				}
			}
		}
		
		//Compute the number of inequivalent embeddings
		int numberOfInequivalentEmbedding = 0;
		for(int i = 0; i < faceTypeCount; ++i){
			numberOfInequivalentEmbedding += numIneqEmbInFaceType[i];
		}
		//// Print the current Toroidal rotation schemes in sortedToroidalRotationSchemesg
		//for(int i = 0; i < faceTypeCount; ++i){
		//    cout << "[ ";
		//    for(int j = 0; j < numberOfFaces;++j){
		//        cout << faceTypes[i][j] << " ";
		//    }
		//    cout << "]: " << numIneqEmbInFaceType[i] << endl;
		//    for(int j = 0; j < numIneqEmbInFaceType[i];++j){
		//        for(int k = 0; k < numberOfVertices; ++k){
		//            cout << "{ ";
		//            for(int l = 0; l < numberOfVertices; ++l)
		//                cout << sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][k][l] << " ";
		//            cout << "} ";
		//        }
		//        cout << endl;
		//
		//    }
		//    cout << endl;
		//}
		//
		//
		//// Print the total number of inequivalent rotation schemes.
		//cout << "Number of unlabeled and unoriented embeddings: "
		// << numberOfInequivalentEmbedding << endl;
		
		/***************************************************************************
		 ****************************************************************************
		 *****End of sorting the torus embedding into  inequivalent ones ************
		 ****************************************************************************
		 ***************************************************************************/
		cout << "Eliminate Equivalent Rotation Schemes" << endl;
		/***************************************************************************
		 ****************************************************************************
		 *****Eliminate the inequivalent torus embeddings that are not the ***********
		 *******packing graph of a locally maximumally dense arrangement ************
		 ****************************************************************************
		 ***************************************************************************/
		
		
		// Now we're going to eliminate all the rotation schemes that
		// have one of the forbitten pattern of faces aroung a vertex.
		// These forbitten patterns are stored in
		// forbiddenAdjacentFacesDegrees. We'll first construct a vector
		// that contains a vector for each faceType, which itself contains
		// a vector for each inequivalent rotation schemes within that faceType. Within
		// each of these vectors there's another one that contains a
		// vector for each vertex. In this last inner vector we store the
		// pattern of faces around that vertex. Basically, we run the
		// faceWalking algorithm again with minor changes. Finally, we
		// eliminate those forbidden paterns.
		
		//A vector of strings used to output the forbidden face pattern
		//  that the the faces surrounding a vertex  can have
		vector <string> forbiddenAdjacentFacesDegrees(13);
		forbiddenAdjacentFacesDegrees[0] = "[3,3,?]";
		forbiddenAdjacentFacesDegrees[1] = "[3,4,?]";
		forbiddenAdjacentFacesDegrees[2] = "[4,4,4]";
		forbiddenAdjacentFacesDegrees[3] = "[3,3,3,?]";
		forbiddenAdjacentFacesDegrees[4] = "[3,3,4,4]";
		forbiddenAdjacentFacesDegrees[5] = "[3,3,3,3,3]";
		forbiddenAdjacentFacesDegrees[6] = "[3,3,3,3,4]";
		forbiddenAdjacentFacesDegrees[7] = "6NghbsAtLeastOneNotTriangle";
		forbiddenAdjacentFacesDegrees[8] = "Vertexwith7(ormore)polygons";
		forbiddenAdjacentFacesDegrees[9] = "MissingCentralEdge";
		forbiddenAdjacentFacesDegrees[10] = "MissingLorREdge";
		forbiddenAdjacentFacesDegrees[11] = "MissingSecondChainEdges";
		forbiddenAdjacentFacesDegrees[12] = "MultigraphWithADigon";

		
		//First determine the maximum number of rotation schemes in any face type
		// store the result in maxNumRotSchInFaceType.
		int maxNumRotSchInFaceTypes = numRotSchInFaceTypes[0];
		for( int i = 1; i < faceTypeCount; ++i){
			if(maxNumRotSchInFaceTypes < numRotSchInFaceTypes[i])
				maxNumRotSchInFaceTypes = numRotSchInFaceTypes[i];
		}
		
		//A vector of vectors to store the degrees of faces adjacent to each vertex.
		//  adjacentFaceDegrees[ face type ] [rotation index] [vertex i] = sorted vector
		// containin the degree of each face adjacent to vertex i
		vector < vector < vector < vector < int > > > > adjacentFacesDegrees(faceTypeCount,
				 vector < vector < vector < int > > > (maxNumRotSchInFaceTypes,
						  vector < vector < int > > (numberOfVertices,
									 vector < int > (2*numberOfFaces, 0))));
		
		//Stores the number of faces adjacent to a vertex in rotation scheme with an index and a face type
		// numOfFacesAdjacentToVertex [ face type ] [ rotation index ] [ vertex j ] = number of faces adjacent to vertex j in rotation
		//   scheme with given index and given face type
		vector < vector < vector < int > > > numOfFacesAdjacentToVertex(faceTypeCount,
				 vector < vector < int > > (maxNumRotSchInFaceTypes,
						  vector < int > (numberOfVertices,0)));
		
		// A list of the inequivalent and non-eliminatable rotation schemese sorted by face type
		//  inequivalentNonEliminatableToroidalRotationSchemes[ face type ] [rotation index] = an inequivalent and non-eliminatable
		//  rotation scheme in the facetype.
		//vector < vector < vector < vector < int > > > > inequivalentNonEliminatableToroidalRotationSchemes(faceTypeCount,
		//		 vector < vector < vector < int > > > (maxNumRotSchInFaceTypes,
		//				  vector < vector < int > > (numberOfVertices,
		//						   vector < int >  (numberOfVertices,-1))));
		
		//search each face type
		for(int i = 0; i < faceTypeCount; ++i){
			
			//search each rotation scheme in that face types
			//for(int ind = 0; ind < numRotSchInFaceTypes[i];++ind){
			for(int ind = 0; ind < numIneqEmbInFaceType[i];++ind){
				
				// store the final list of Rotation schemes - each of these will be have a vector
				//  that lists the
				//inequivalentNonEliminatableToroidalRotationSchemes[i][ind] = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]];
				
				// set tempGrphAdjMatrix to grphAdjMatrix adjecency
				for(int i1 = 0; i1 < numberOfVertices; ++i1){
					for(int j1 = 0; j1 < numberOfVertices; ++j1){
						tempGrphAdjMatrix[i1][j1] = grphAdjMatrix[i1][j1];
					}
				}
				
				// numOfAdjFacesWalked stores number of faces walked that are adjacent to a vertex.
				// It shouldn't exceed numberOfFaces at any time.
				int numOfAdjFacesWalked = 0;
				
				// tempNumberOfEdges records the number of faces in the current face.
				int tempNumberOfEdges = 0;
				
				//As we walk all the faces adjacent to a vertex, we need to be sure to count
				// the faces correctly when a face contains the same vertex twice (or possibly more)
				//  This happens in K_6-2v2_Ver7_8.  So store an integer to record the number of times
				//  a vertex is visited in a face walk.
				int multipleVertexVisit = 0;
				
				for(int j = 0; j < numberOfVertices; ++j){
					for(int k = 0; k < numberOfVertices; ++k){
						//if there is an edge between j and k then tempGrphAdjMatrix[j][k] == 1 and the following statements are executed
						if(tempGrphAdjMatrix[j][k] == 1){
							// set current egde to the one for which tempGrphAdjMatrixs[j][k]=1 (ie. an unmarked one)
							currentEdge[0] = j;
							currentEdge[1] = k;
							currentEdge[2] = -1; //force the while loop to execute at least once
							// while current edge is not equal to tempGrphAdjMatrix[j][k]
							while(currentEdge[2] != j || currentEdge[1] != k){
								// currentEdge[2] is just temp storage for currentEdge[1]
								currentEdge[2] = currentEdge[1];
								//Here we are using the fact that the next edge in after <j,k> is <k,p_k(j)>
								// where p is the current rotation scheme (j=currentEdge[0], k=currentEdge[1])
								// notice how nice the cartesian coordinates are to use (NO Methods Called!)
                                currentEdge[1] = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][currentEdge[1]][currentEdge[0]];
								//currentEdge[1] = inequivalentNonEliminatableToroidalRotationSchemes[i][ind][currentEdge[1]][currentEdge[0]];
								
								//each time the vertex j is the leading vertex of currentEdge increment multipleVertexVisit
								// this will be executed at least once in every face walk and twice or more when walking the
								// face visits the same vertex twice (or more)
								if (currentEdge[1]==j) {
                                    
									multipleVertexVisit++;
								}
								
								currentEdge[0] = currentEdge[2];
								//marked the directed edge
								tempGrphAdjMatrix[currentEdge[0]][currentEdge[1]]++;
								//if the currentEdge[0] is NOT a degree 2 vertex then increase the number of edges traced/walked
								if(degree[currentEdge[0]] > 2){
												tempNumberOfEdges++;
								}
							}// finished walking a face
                            
							// Store the number of edges of the current face. As adjacent to vertex j
							//  adjacentFacesDegree[ face type ][ rotation index ] [vertex j ] [face number numOfFacesWalked] = degree of face (i.e. tempNumberOfEdges)
							//  If the vertex j has been visited multiple times then this face degree must be stored multiple times
							//  It is possible for this cause a segmentation fault because if numOfFacesWalked exceeds numberOfFaces
							//  then adjacentFacesDegrees can't store the information, but this would require at least one vertex to be
							//  adjacent to all faces and at least one twice - not likely.
							
							for(int i1=0; i1< multipleVertexVisit; ++i1){
								adjacentFacesDegrees[i][ind][j][numOfAdjFacesWalked] = tempNumberOfEdges;
								// increase the number of faces walked adjacent to vertex by 1 for each time the vertex was visited
								numOfAdjFacesWalked++;
							}
							
							//reset the multiple Vertex Visit variable
							multipleVertexVisit = 0;
							
							//reset the number of edge walked for the next face
							tempNumberOfEdges = 0;
							
						}
					}
					//reset the graph matrix
					for(int i1 = 0; i1 < numberOfVertices; ++i1){
						for(int j1 = 0; j1 < numberOfVertices; ++j1){
							tempGrphAdjMatrix[i1][j1] = grphAdjMatrix[i1][j1];
						}
					}
					
					//Stores the number of faces adjacent to vertex j in rotation scheme with index ind and face type i
					numOfFacesAdjacentToVertex[i][ind][j] = numOfAdjFacesWalked;
                    
					//sort the face degrees adjacent to vertex j
					sort(adjacentFacesDegrees[i][ind][j].begin(), adjacentFacesDegrees[i][ind][j].begin()+numOfAdjFacesWalked);
					
                    
					//reset the number of faces walked adjacent to a vertex
					numOfAdjFacesWalked = 0;
                    
				} //end vertices loop (j)                
			} //end number of inequivalent indices loop (ind)
            

            
		} //end face type loop (i)
		
 
//		// //Print result
//        for(int i = 0; i < faceTypeCount; ++i){
//            cout << "[ ";
//            for(int j = 0; j < numberOfFaces;++j){
//                cout << faceTypes[i][j] +1 << " ";
//            }
//            cout << "]: " << numIneqEmbInFaceType[i] << endl;
//            for(int ind = 0; ind < numIneqEmbInFaceType[i];++ind){
//                for(int j = 0; j < numberOfVertices; ++j){
//                    cout << j<< " { ";
//                    for(int i1 = 0; i1 < numberOfVertices; ++i1)
//                        cout << sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][j][i1] << " ";
//                    cout << "} "<< endl;
//                }
//                cout << endl;
//                for(int j = 0; j < fakeVertex; ++j){
//                    cout << " [ ";
//                    for(int i1 = 0; i1 < numOfFacesAdjacentToVertex[i][ind][j]; ++i1)
//                        cout << adjacentFacesDegrees[i][ind][j][i1] << " ";
//                    cout << "] ";
//                }
//                cout << endl;
//            }
//            cout << endl;
//        }
		
		// For each rotation scheme within a facetype we store a
		// vector where each element takes values as follows:
		// [0]: 0 if it fails (that is, it does have a vertex matches a forbidden face pattern or, in the case of a multigraph, is missing an edge) and 1 if it doesn't
		// [1]: if the first index is == 1, this index references the forbidden pattern index + 1 or the multigraph edge problem index +1. It is meaningless otherwise.
		// [2]: if the first index is == 1, this index references vertex index that has the forbidden pattern or the multigraph vertex center. It is meaningless otherwise
		vector < vector < vector < int > > > finalRotationSchemeInfo(faceTypeCount,
				 vector < vector < int > > (maxNumRotSchInFaceTypes,
					      vector < int > (3, -1)));
		
		// A vector to hold a list of the CW neighbors of a vertex, vert:  neighbors[vert] is a list of length 2*numberOfNeighbors[vert] of the 
		//    neighbors of vertex vert in a special format
		//      neighbors[vert][0], neighbors[vert][2],.... neighbors[vert][2*numberOfNeighbors[vert]-2] is a CW list of the FAKE neighbors of vert
	    //      neighbors[vert][1], neighbors[vert][3],.... neighbors[vert][2*numberOfNeighbors[vert]-1] is a CW list of the REAL neighbors of vert
		//   Such that
		///     sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][vert][ nieghbors[vert][q (even)] ] = neighbors[vert][q+1]
		vector < vector <int > > neighbors (fakeVertex,
				 vector	<int> (2*fakeVertex,-1));
		vector < int > numberOfNeighbors (fakeVertex,-1); // a vector to hold the number of nieghbors (i.e. numberOfNeighbors [j]= the number of 
															//  (real) vertices adjacent to (real) vertex j
	
		int repeated = 0; //an integer set to the number of repeated vertices adjacent to a vertex
		vector < int > repeatIndices (2*numberOfVertices, -1); // a list of pairs of indices so that if repeatIndices[2*i] <> -1 then
																// neighbors[repeatIndices[2*i]=neighbors[repeatIndices[2*i+1]

		//Variables to record the numbers of the fakevertices between two real vertices in a potential forbidden multigraph pattern
		//  these two help determine if a triangle is formed with the appriproiate vertices.
		int next1 = -1;
		int next2 = -1;
		int next3 = -1;
		
		//Variables to help mange the indices of repeated vertice and to search for the forbidden pattern
		int repeatedSecondIndex = -1;
		int numberRealVerticesBetween = -1;
		int numberRealVerticesAfter = -1;
	
		// mark the rotation Schemes containing a forbidden patern by marking the cooresponding entry in finalRotationSchemeInfo
		// search all the face types
		for(int i = 0; i < faceTypeCount; ++i){
			// search all the rotation schemes in the face type
			for(int ind = 0; ind < numIneqEmbInFaceType[i];++ind){
				
				
				// check to see if it contains a vertex with one of the forbidden pattern
				// forbiddenAdjacentFacesDegrees =[[3,3,'?'],[3,4,'?'],[4,4,4],
				// [3,3,3,'?'],[3,3,4,4],[3,3,3,3,3],[3,3,3,3,4],
				// ['Vertex with 6 neighbors at least one not a triangle']]
				// ['Vertex with 7 (or more) polygons']];
				for(int j = 0; j < numberOfVertices; ++j){
					// to begin assume that rotation scheme at faceType i, index ind and vertex j fails
					finalRotationSchemeInfo[i][ind][0] = 0;
					
					//the vertex is set in the finalRotationSchemeInfo in the case that rotation scheme fails
					finalRotationSchemeInfo[i][ind][2] = j;
					
					if(numOfFacesAdjacentToVertex[i][ind][j] > 6)
					{
						finalRotationSchemeInfo[i][ind][1] = 9;
						break; //exits the number of vertices loop (j)
					}
					
					if(numOfFacesAdjacentToVertex[i][ind][j] == 6){
						if(adjacentFacesDegrees[i][ind][j][5] > 3)
						{
							finalRotationSchemeInfo[i][ind][1] = 8;
							break; //exits the number of vertices loop (j)
						}
					}
					
					if(numOfFacesAdjacentToVertex[i][ind][j] == 5){
						
						if(adjacentFacesDegrees[i][ind][j][4] == 4 &&
						   adjacentFacesDegrees[i][ind][j][3] == 3)
						{
							finalRotationSchemeInfo[i][ind][1] = 7;
							break; //exits the number of vertices loop (j)
						}
						
						if(adjacentFacesDegrees[i][ind][j][4] == 3)
						{
							finalRotationSchemeInfo[i][ind][1] = 6;
							break; //exits the number of vertices loop (j)
						}
					}
					
					if(numOfFacesAdjacentToVertex[i][ind][j] == 4){
						if(adjacentFacesDegrees[i][ind][j][3] == 4 &&
						   adjacentFacesDegrees[i][ind][j][2] == 4 &&
						   adjacentFacesDegrees[i][ind][j][1] == 3)
						{
							finalRotationSchemeInfo[i][ind][1] = 5;
							break; //exits the number of vertices loop (j)
						}
						if(adjacentFacesDegrees[i][ind][j][2] == 3)
						{
							finalRotationSchemeInfo[i][ind][1] = 4;
							break; //exits the number of vertices loop (j)
						}
					}
					
					if(numOfFacesAdjacentToVertex[i][ind][j] == 3){
						
						if(adjacentFacesDegrees[i][ind][j][2] == 4 &&
						   adjacentFacesDegrees[i][ind][j][0] == 4)
						{
							finalRotationSchemeInfo[i][ind][1] = 3;
							break; //exits the number of vertices loop (j)
						}
						
						if(adjacentFacesDegrees[i][ind][j][1] == 4 &&
						   adjacentFacesDegrees[i][ind][j][0] == 3)
						{
							finalRotationSchemeInfo[i][ind][1] = 2;
							break; //exits the number of vertices loop (j)
						}
						
						if(adjacentFacesDegrees[i][ind][j][1] == 3)
						{
							finalRotationSchemeInfo[i][ind][1] = 1;
							break; //exits the number of vertices loop (j)
						}
					}
					
					//If this executes then the rotation scheme at typeType i, index ind and vertex j passes (
					//  Unless this is the last vertex, this is immediately overwritten with a fail (0) at the 
					//  start of the next loop. If j is the last vertex then this next line executing means that the rotation scheme 
					//  passes (i.e. does NOT contain a forbiden face type pattern
					finalRotationSchemeInfo[i][ind][0] = 1;
				}

				// For each rotation scheme NOT containing a forbiden face pattern AND which is a multigraph
				// check to see if the multigraph embedding is missing an edge, i.e. contains 
				// forbiddenAdjacentFacesDegrees[9] = "Multigraph Pattern - Missing Central edge on one side";
				// forbiddenAdjacentFacesDegrees[10] = "Multigraph Pattern - Missing left or right edge on one side";
				// forbiddenAdjacentFacesDegrees[11] = "Multigraph Pattern - Second chain of multiple tangencies";

				if (multiGraph && finalRotationSchemeInfo[i][ind][0] == 1) {
					//reset the neighbors vector to all -1s
					for(int i1 =0; i1 < fakeVertex; i1++){
						//reset the number of neighbors of vertex i1 to 0
						numberOfNeighbors[i1] = 0;
						for(int i2 =0 ; i2 < 2*fakeVertex; i2++){
							neighbors[i1][i2]=-1;
						}
					}
					
					//first convert to the rotation scheme to non-cartesian so that it is easier to search for connections, but 
					// of a certain form to make it easier to see the fake vertices that are between the real vertices and j
					//
					// neighbors[vert] is a list of length 2*numberOfNeighbors[vert] of the 
					//    neighbors of vertex vert in a special format
					//      neighbors[vert][0], neighbors[vert][2],.... neighbors[vert][2*numberOfNeighbors[vert]-2] is a CW list of the FAKE neighbors of vert (evens)
					//      neighbors[vert][1], neighbors[vert][3],.... neighbors[vert][2*numberOfNeighbors[vert]-1] is a CW list of the REAL neighbors of vert (odds)
					//   Such that
					///     sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][vert][ nieghbors[vert][q (even)] ] = neighbors[vert][q+1]
					for(int j = 0; j < fakeVertex; ++j){				
						// output to neighbors the rotationScheme at vertex j NOT in cartesian coordinates 
						//  (i.e. output the cycle of neighboring vertices at each vertex)
						//first find a vertex that is not mapped to itself under the rotationScheme at vertex j, call it startVertex
						int startVertex = 0;
						int writeStartVertex = 0; //this is the value that is written to the file when dealing with a mulitgraph
						for(int l = 0; l < numberOfVertices; ++l){
							if (not(sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][j][l]==l)){
								startVertex = l;
								writeStartVertex = l;
								// make sure that write start vertex is not a fake vertex
								if(writeStartVertex >= fakeVertex) {
									writeStartVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][writeStartVertex][j];
								};
								break;
							}
						}
												
						
						//output the starting vertices to the neighbors and increment numberOfNeighbors[j]
						neighbors[j][2*numberOfNeighbors[j]] = startVertex;
						neighbors[j][2*numberOfNeighbors[j]+1] = writeStartVertex;
						numberOfNeighbors[j]++;
						
						
						// compute the next vertex in the rotation at vertex j (we know that this is not startVertex)
						int nextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][j][startVertex];
						// compute the next vertex to write in the rotation scheme to file
						int writeNextVertex = nextVertex;
						//make sure it isn't fake
						if (writeNextVertex>=fakeVertex) {
							writeNextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][writeNextVertex][j];
						};
						
						//trace the neighbors of vertex j, outputing them until we return to the start vertex
						while (nextVertex!=startVertex) {
							neighbors[j][2*numberOfNeighbors[j]] = nextVertex;
							neighbors[j][2*numberOfNeighbors[j]+1] = writeNextVertex;
							numberOfNeighbors[j]++;
							nextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][j][nextVertex];
							writeNextVertex = nextVertex;
							//make sure it isn't fake
							if (writeNextVertex>=fakeVertex) {
								writeNextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][writeNextVertex][j];
							};
						}
					}
					
//					cout << "T" << i+1 << "_" << ind+1 << endl;
//					for(int j1=0; j1 < fakeVertex ; j1++){
//						cout << "Vertex " << j1 << " Fake(even): ";
//						for(int k=0;k < numberOfNeighbors[j1]; k++){
//							cout << neighbors[j1][2*k] << " " ;
//						}
//						cout << endl;
//						cout << "Vertex " << j1 << " Real(odd): ";
//						for(int k=0;k < numberOfNeighbors[j1]; k++){
//							cout << neighbors[j1][2*k+1] << " " ;
//						}
//						cout << endl;
//					}
//					cout << endl;
					
//					//Check this multigraph for digons first-- not sure how.....
//					for (int i1 = 0; i1 < numberOfNeighbors[j]; i1++) { 
//						// for each neighbor check if there is 
//					}
					
					//now search each vertex for a forbidden pattern
					for(int j=0; j < fakeVertex ; j++){
						// to begin assume that rotation scheme at faceType i, index ind and vertex j fails
						finalRotationSchemeInfo[i][ind][0] = 0;
						
						//the vertex is set in the finalRotationSchemeInfo in the case that rotation scheme fails
						finalRotationSchemeInfo[i][ind][2] = j;
						
						//First check to see if the vertex at j is connected to the same REAL vertex in two ways
						//   Now search the rotatation at vertex j for the pattern that is (A,...,B,...,C,...A',...) 
						if (numberOfNeighbors[j]>3) { // for the forbidden pattern to appear there must be at least 4 vertices adjacent to vertex j
							//rest repeated varible for this vertex
							repeated = 0; //an integer to record the number of repeated vertices adjacent to vertex j
							// reset the repeatIndices vector
							for(int i1=0; i1 <2*fakeVertex; i1++){
								repeatIndices[i1]=-1; // a list of pairs of indices so that if repeatIndices[2*i] <> -1 then
							}	     					// neighbors[j][repeatIndices[2*i]]=neighbors[repeatIndices[2*i+1]]
							//search the list of neighbors for a repeated vertex
							for(int first=0; first < 2*numberOfNeighbors[j]; first++){
								for(int second=first+1; second < 2*numberOfNeighbors[j]; second++){
									if (neighbors[j][first]==neighbors[j][second]) {
										repeatIndices[2*repeated]=first;
										repeatIndices[2*repeated+1]=second;
										repeated++;
									}
								}
							}
//							cout << "repeated Indices: ";
//							for (int q1 =0; q1<2*repeated;q1++){
//								cout << repeatIndices[q1] << " ";
//							}
//							cout << endl;
//							
//							cout << "number Of Neighbors: ";
//							for (int q1 =0; q1<fakeVertex;q1++){
//								cout << numberOfNeighbors[q1] << " ";
//							}
//							cout << endl;
							
							// if there is at least one pair of repeated indices, check for the forbidden multigraph pattern
							for (int k1 =0 ; k1 <repeated; k1++) {
								//shift the pair of matching vertices so that the first one has index 0
								vector <int> shift(2*numberOfNeighbors[j],-1);
								for (int k2 =0; k2 <2*numberOfNeighbors[j]; k2++){
									shift[k2]=neighbors[j][(repeatIndices[2*k1]-1+k2)%(2*numberOfNeighbors[j])];
								}
//								cout << "shifted vertex " << j << "-";
//								for (int q1 =0; q1<2*numberOfNeighbors[j];q1++){
//									cout << shift[q1] << " ";
//								}
//								cout << endl;
								
								//now the repeated verteice are in postions one and (repeatIndices[2*k1+1]-repeatIndices[2*k1])+1 and there
								// are 1/2*(repeatIndices[2*k1+1]-repeatIndices[2*k1])-1 real vertices between them and there are 
								// 
								// To make this easier to read create varibles for these values
								repeatedSecondIndex = (repeatIndices[2*k1+1]-repeatIndices[2*k1])+1;
								numberRealVerticesBetween = (repeatIndices[2*k1+1]-repeatIndices[2*k1])/2-1;
								numberRealVerticesAfter = numberOfNeighbors[j] - (numberRealVerticesBetween+2);
								
								//check to see if there are two vertices bewteen the repeated vertices on the list of neighbors
								if (numberRealVerticesBetween >1){
//									cout << "Search Between" << endl;
									//search all the vertices between the repeated vertices
									for(int compare1=1; compare1 < numberRealVerticesBetween ; compare1++){
										for(int compare2=compare1+1; compare2 <= numberRealVerticesBetween ; compare2++){
											//reset the helping variables
											next1 = -1;
											next2 = -1;
											next3 = -1;
								
											//make sure that the shift[2*compare1+1] and shift[2*compare2+1] are different
											//  becuase then they must be connected
											if (shift[2*compare1+1] != shift[2*compare2+1] ) {
												//make sure vertices shift[2*compare1+1] and shift[2*compare2+1] are connected, AND
												// FORM A TRIANGLE WITH vertex j, if not then this graph is eliminatable
												// use the rotation scheme to see if a triangle is formed
												next1 = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][shift[2*compare1+1]][shift[2*compare1]];
												next2 = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][shift[2*compare2+1]][shift[2*compare2]];
												next3 = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][shift[repeatedSecondIndex]][shift[repeatedSecondIndex-1]];
//												cout << "next 2: " << next2 << endl;
//												cout << "Rotation Scheme:" << endl;
//												for(int k = 0; k < numberOfVertices; ++k){
//													cout << "vert " << k << "{ ";
//													for(int l = 0; l < numberOfVertices; ++l) {
//														cout << sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][k][l] << " ";
//													}
//													cout << "}" << endl;
//												}
//												cout << endl;
												// check that 
												//
												// j, shift[2*compare1],shift[2*compare1+1],next2,shift[2*compare2+1], shift[2*compare2]
												//
												//    forms a triangle, if not then this is a multigraph forbidden pattern --> check the corners and outside edge
												if (not (sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][next2][shift[2*compare2+1]] == shift[2*compare1+1] and
														 sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][shift[2*compare1+1]][next2] == shift[2*compare1] and
														 sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][j][shift[2*compare1]] == shift[2*compare2])
													){
														finalRotationSchemeInfo[i][ind][1] = 10;
														cout << "rejectInbetween"<< endl;
														goto next;
												}
//												cout << "next 1 & 3: " << next1 << " " << next3 << endl;

												// check that 
												//
												// j, shift[0] , shift[1], next1, shift[2*compare1+1], shift[2*compare1]
												//
												// OR
												//
												// shift[repeatedSecondIndex],shift[repeatedSecondIndex-1], j, shift[2*compare2] ,shift[2*compare2+1, next3
												//
												//    forms a triangle, if not then this is a multigraph forbidden pattern
												if (not (sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][next1][shift[2*compare1+1]] == shift[1] and
														 sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][shift[1]][next1] == shift[0] and
														 sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][j][shift[0]] == shift[2*compare1])
													and
													not (sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][shift[repeatedSecondIndex]][shift[repeatedSecondIndex-1]] == next3 and
														 sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][next3][shift[2*compare2+1]] == shift[repeatedSecondIndex] and
														 sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][j][shift[2*compare2]] == shift[repeatedSecondIndex-1])
													
													){
													finalRotationSchemeInfo[i][ind][1] = 11;
													cout << "rejectBetweenLeft/Right"<< endl;
													goto next;
												}
											}
										}
									}
								}  // end the search for missing edges BETWEEN the repeated vertices
								
								// check to see if there are two vertices after the repeated vertices
								// first there has to at least 2 vertices after the second repeat vertice
								if (numberRealVerticesAfter>1) {
//									cout << "Search After" << endl;
									//search all the vertices after the repeated vertices
									for(int compare1= numberRealVerticesBetween+2; compare1 < numberOfNeighbors[j] ; compare1++){
										for(int compare2=compare1+1; compare2 < numberOfNeighbors[j] ; compare2++){
											//reset the helping variables
											next1 = -1;
											next2 = -1;
											next3 = -1;

											//make sure that the shift[2*compare1+1] and shift[2*compare2+1] are different
											//  becuase then they must be connected
											if (shift[2*compare1+1] != shift[2*compare2+1] ) {
												//make sure vertices shift[2*compare1+1] and shift[compare2] are connected, AND
												// FORM A TRIANGLE WITH vertex j, if not then this graph is eliminatable
												// use the rotation scheme to see if a triangle is formed
												next1 = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][shift[2*compare1+1]][shift[2*compare1]];
												next2 = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][shift[2*compare2+1]][shift[2*compare2]];
												next3 = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][shift[1]][shift[0]];
//												cout << "next 2: " << next2 << endl;
//												cout << "Rotation Scheme:" << endl;
//												for(int k = 0; k < numberOfVertices; ++k){
//													cout << "vert " << k << "{ ";
//													for(int l = 0; l < numberOfVertices; ++l) {
//														cout << sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][k][l] << " ";
//													}
//													cout << "}" << endl;
//												}
//												cout << endl;
												// check that 
												//
												// j, shift[2*compare1],shift[2*compare1+1],next2,shift[2*compare2+1], shift[2*compare2]
												//
												//    forms a triangle, if not then this is a multigraph forbidden pattern --> check the corners and outside edge
												if (not (sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][next2][shift[2*compare2+1]] == shift[2*compare1+1] and
														 sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][shift[2*compare1+1]][next2] == shift[2*compare1]  and
														 sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][j][shift[2*compare1]] == shift[2*compare2])
													){
													finalRotationSchemeInfo[i][ind][1] = 10;
													cout << "rejectAfter"<< endl;
													goto next;
												}
//												cout << "next 1 & 3: " << next1 << " " << next3 << endl;
												
												// check that 
												//
												// j, shift[0] , shift[1], next1, shift[2*compare1+1], shift[2*compare1]
												//
												// OR
												//
												// shift[repeatedSecondIndex],shift[repeatedSecondIndex-1], j, shift[2*compare2] ,shift[2*compare2+1, next3
												//
												//    forms a triangle, if not then this is a multigraph forbidden pattern
												if (not (sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][next1][shift[2*compare1+1]] == shift[repeatedSecondIndex] and
														 sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][shift[repeatedSecondIndex]][next1] == shift[repeatedSecondIndex-1] and
														 sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][j][shift[repeatedSecondIndex-1]] == shift[2*compare1])
													and
													not (sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][shift[2*compare2+1]][next3] == shift[2*compare2] and
														 sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][next3][shift[2*compare2+1]] == shift[1] and
														 sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][ind]][j][shift[2*compare2]] == shift[0])
													
													){
													finalRotationSchemeInfo[i][ind][1] = 11;
													cout << "rejectAfterLeft/Right"<< endl;
													goto next;
												}
											}
										}
									}	
								}// end the search for missing edges AFTER the repeated vertices
								
								//If the code reaches here there is a repeat vertex
								//search to make sure that there is a left of right edge on one side 
								
							}// end the search if there are repeated vertices
						}// end of if statement for searching the vertex j ONLY if it has 4 or more neighbors	
						
						//If this executes then the rotation scheme at typeType i, index ind and vertex j passes (
						//  Unless this is the last vertex, this is immediately overwritten with a fail (0) at the 
						//  start of the next loop. If j is the last vertex then this means that the rotation scheme 
						//  passes (i.e. does NOT contain a forbiden multigraph pattern)
						finalRotationSchemeInfo[i][ind][0] = 1;
					}// end of for statement searching vertex j
				}// end of if statement searching multigraphs that do not contain a forbidden face pattern
				
			next:;
			}// end of for statement searching the ind (index of the rotation scheme)
		}// end of the for statement searching the i face type
		
		/***************************************************************************
		 ****************************************************************************
		 *****End of eliminate the inequivalent torus embedding that are not the ****
		 *******packing graph of a locally maximumally dense arrangement ************
		 ****************************************************************************
		 ***************************************************************************/
		cout << "Export Files" << endl;
		/***************************************************************************
		 ****************************************************************************
		 *****Export Results to  files***********************************************
		 ****************************************************************************
		 ***************************************************************************/
		
		//store the current directory where the program was executed
		//string directory = argv[0];//program full path + name of binary file
		//cout << directory<<endl;
		//directory.erase(directory.find_last_of('T'));//remove name of binary file The executable name is TorusEmbedding
		//directory.erase(directory.find_last_of('/')+1);//remove name of binary file
		string directory = "/Users/danielralston/Desktop/REU\ 2019/BidispersedCircleTorusMultigraph2018/LastOutput/";
		
		//A file to hold the Graphs and Graph output for those
		//  rotation schemes that are torus embeddable and
		//  DO NOT contain a forbidden face pattern.
		string torusEmbeddings = directory + graphName+"_Torus_Embeddings.txt";
		ofstream torusEmbeddingFile(torusEmbeddings.c_str());
		
		//A file to hold the Graphs and Graph output for those
		//  rotation schemes that are torus embeddable and
		//  DO contain a forbidden face pattern.
		string torusEmbeddingForbidden = directory + graphName+"_Torus_Embeddings_Forbidden.txt";
		ofstream torusEmbeddingForbiddenFile(torusEmbeddingForbidden.c_str());
		
		//A file to hold the summary information about the
		// graph and how it embedds on the torus
		string summary = directory + graphName+"_Summary.txt";
		ofstream summaryFile(summary.c_str());
		
		//A file to hold the names of the embeddings of the graph
		// on a torus that DO NOT contain a forbidden face pattern
		// This is to help in collecting all the eps files
		// from the graphs and groups eps out of each graph into one sheet.
		string embeddingNames = directory + graphName+"_Embedding_Names.txt";
		ofstream embeddingNamesFile(embeddingNames.c_str());
		
		//A file to hold the names of the embeddings of the graph
		// on a torus that DO contain a forbidden face pattern
		// This is to help in collecting all the eps files
		// from the graphs and groups eps out of each graph into one sheet.
		string embeddingNamesForbidden = directory + graphName+"_Embedding_Names_Forbidden.txt";
		ofstream embeddingNamesForbiddenFile(embeddingNamesForbidden.c_str());
		
		//a long int to hold the position in each file so that a comma can be overwritten
		long pos;
		
		//record the number of rotation schemes in each face type that contain a
		// forbidden face pattern. numberOfFinalFaceDegreeTypes[ face type i] = number of
		//  rotation schemes that contain a forbidden face pattern in face type i
		vector < int > numberOfFinalFaceDegreeTypes(faceTypeCount, 0);
		for(int i = 0; i < faceTypeCount; ++i){
			for(int ind = 0; ind < numIneqEmbInFaceType[i];++ind){
				//count only those for which the finalRotationScheme indicates that
				// it contains a forbidden face pattern.
				if(finalRotationSchemeInfo[i][ind][0] == 1)
					numberOfFinalFaceDegreeTypes[i]++;
			}
		}
		
		//count all the rotation schemes that contains a forbidden face pattern
		int totalNumberOfFinalFaceDegreeTypes = 0;
		for(int i = 0; i < faceTypeCount; ++i){
			totalNumberOfFinalFaceDegreeTypes += numberOfFinalFaceDegreeTypes[i];
		}
		
		
		// change the tempGrphAdjMatrix so that at an [i][j] location either
		// tempgrphAdjMatrix[i][j] = the number of the edge connecting vertex i and j
		//  or 0 if there is no edge or 
	    // all edges incident to a degree 2 vertex have the same number or an edge between two fake vertices is edge zero
	    // This helps for exporting to the graphs and groups file
	
	//First set all the entries of tempGrphAdjMatrix to zero
	for(int i = 0; i < numberOfVertices; ++i){
		for(int j = 0; j < numberOfVertices; ++j){
			tempGrphAdjMatrix[i][j] = 0;
		}
	}
	
		int edgeCounter = 0;
	    //first count the edges connecting non-fake vertices
		for(int i = 0; i < fakeVertex; ++i){
			tempGrphAdjMatrix[i][i]=0;
			for(int j = i+1; j < fakeVertex; ++j){
				if (grphAdjMatrix[i][j]!=0) {
						edgeCounter++;
						tempGrphAdjMatrix[i][j] = edgeCounter;
						tempGrphAdjMatrix[j][i] = edgeCounter;
				}
			}
			
		}
		//Now number the multi-edges which have grphAdjMatrix[i1][j]=1 and grphAdjMatrix[i2][j]=1 for 0<=ji<j2<fakeVertex 
	   for(int j = fakeVertex; j < numberOfVertices; ++j){
		//find those values of j for which we get these two ones
		   int firstFound = -1;
		   for(int i = 0; i < fakeVertex; ++i){ //edges between fake vertices and real ones
			     if (grphAdjMatrix[i][j]!=0) {
				     if (firstFound<0) {
					    firstFound = i;
					 };
					 if (firstFound >= 0 && firstFound != i) {
						 edgeCounter++;
						 tempGrphAdjMatrix[i][j] = edgeCounter;
						 tempGrphAdjMatrix[j][i] = edgeCounter;
						 tempGrphAdjMatrix[firstFound][j] = edgeCounter;
						 tempGrphAdjMatrix[j][firstFound] = edgeCounter;
					 };
				 };
		   };
	   };
	
	//first set some helping variables for marking the loops
	int i1value = -1;
	int sum = 0;
	
		//Now mark all the loops which have grphAdjMatrix[i1][j]=1 for exactly one i1 such that 0<=i1<fakeVertex and the other part of the loop has
		//  grphAdjMatrix[i1][j1]=1 for some j1 not equal to j (because of the way we are searching we will assume j1>j)
	for(int j = fakeVertex; j < numberOfVertices; ++j){
			//first check to see if this vertex j is a part of a loop
		sum = 0;
		for(int i=0; i < fakeVertex; ++i){
			sum = sum + grphAdjMatrix[i][j];
		};
		if (sum > 1) {
			break; // sum > 1  happens when either j is a part of a multiedge or has already been checked.
		};
		//now find the first (and only) value of i1 such that grphAdjMatrix[i1][j]=1  for 0<=i1<fakeVertex
		i1value = -1;	
		for(int i = 0; i < fakeVertex; ++i){ //edges between fake vertices and real ones
			if (grphAdjMatrix[i][j]!=0) {
				i1value = i;
				break;
			};
		};
		//now find the value of j1 so that grphAdjMatrix[i1][j1]=1 and j1 is a part of a loop and j1>j
		for(int j1 = j+1; j1 < numberOfVertices; ++j1){
			//first check to see if this vertex j is a part of a loop and not a multi edge and has not been already counted
			sum = 0;
			for(int i=0; i < fakeVertex; ++i){
				sum = sum + grphAdjMatrix[i][j1];
			};
			if (sum == 1 && grphAdjMatrix[i1value][j1]==1) {
				edgeCounter++;
				tempGrphAdjMatrix[i1value][j] = edgeCounter;
				tempGrphAdjMatrix[j][i1value] = edgeCounter;
				tempGrphAdjMatrix[i1value][j1] = edgeCounter;
				tempGrphAdjMatrix[j1][i1value] = edgeCounter;
				break;
			};
		}
	}
		
		//Print the adjacency matrix grphAdjMatrix.
//		for(int i = 0; i < numberOfVertices; ++i){
//		    for(int j = 0; j < numberOfVertices; ++j){
//		        printf(" %2d",tempGrphAdjMatrix[i][j]);
//		    }
//		    printf("\n");
//		}
//		printf("\n");
		if (faceTypeCount!=0){
            //zeroth output a summary line with the information
            embeddingNamesFile << "NumberOfFaceTypes " << "ListOfFaceTypes " << "NumberTorRotationSchemed " << "InequivalentEmbedding " << "Non-Eliminatable " <<"Eliminatable "<<endl; 
            
            //First output the number of face types followed by a C compatible list of length faceTypeCount listing each face type
            embeddingNamesFile << faceTypeCount << " {";
            for(int i=0; i< faceTypeCount-1; ++i){
                embeddingNamesFile << "{";
                for(int j1 = 0; j1 < numberOfFaces-1;++j1){
                    embeddingNamesFile << faceTypes[i][j1] << ",";
                }
                embeddingNamesFile << faceTypes[i][numberOfFaces-1] << "},";
            }

            embeddingNamesFile << "{";
            for(int j1 = 0; j1 < numberOfFaces-1;++j1){
                embeddingNamesFile << faceTypes[faceTypeCount-1][j1] << ",";
            }
            embeddingNamesFile << faceTypes[faceTypeCount-1][numberOfFaces-1] << "}} ";
            //second output the number of toroidal rotation schemes, followed by the number of inequivalent embeddings, then the number of non-eliminatable then the number of the eliminatatble
            embeddingNamesFile << numToroidalRotationSchemes << " " << numberOfInequivalentEmbedding
            << " " << totalNumberOfFinalFaceDegreeTypes << " " << numberOfInequivalentEmbedding - totalNumberOfFinalFaceDegreeTypes
            << endl;
            
            //zeroth output a summary line with the information
            embeddingNamesForbiddenFile << "NumberOfFaceTypes " << "ListOfFaceTypes " << "NumberTorRotationSchemed " << "InequivalentEmbedding " << "Non-Eliminatable " <<"Eliminatable "<<endl; 
            
            //First output the number of face types followed by a C compatible list of length faceTypeCount listing each face type
            embeddingNamesForbiddenFile << faceTypeCount << " {";
            for(int i=0; i< faceTypeCount-1; ++i){
                embeddingNamesForbiddenFile << "{";
                for(int j1 = 0; j1 < numberOfFaces-1;++j1){
                    embeddingNamesForbiddenFile << faceTypes[i][j1] << ",";
                }
                embeddingNamesForbiddenFile << faceTypes[i][numberOfFaces-1] << "},";
            }
            embeddingNamesForbiddenFile << "{";
            for(int j1 = 0; j1 < numberOfFaces-1;++j1){
                embeddingNamesForbiddenFile << faceTypes[faceTypeCount-1][j1] << ",";
            }
            embeddingNamesForbiddenFile << faceTypes[faceTypeCount-1][numberOfFaces-1] << "}} ";
            //second output the number of toroidal rotation schemes, followed by the number of inequivalent embeddings, then the number of non-eliminatable then the number of the eliminatatble
            embeddingNamesForbiddenFile << numToroidalRotationSchemes << " " << numberOfInequivalentEmbedding
            << " " << totalNumberOfFinalFaceDegreeTypes << " " << numberOfInequivalentEmbedding - totalNumberOfFinalFaceDegreeTypes
            << endl;
        } else {
            //zeroth output a summary line with the information
            embeddingNamesFile << "NumberOfFaceTypes " << "ListOfFaceTypes " << "NumberTorRotationSchemed " << "InequivalentEmbedding " << "Non-Eliminatable " <<"Eliminatable "<<endl;
            //zeroth output a summary line with the information
            embeddingNamesForbiddenFile << "NumberOfFaceTypes " << "ListOfFaceTypes " << "NumberTorRotationSchemed " << "InequivalentEmbedding " << "Non-Eliminatable " <<"Eliminatable "<<endl;
            embeddingNamesForbiddenFile << "0 {} 0 0 0 0"<<endl;
            embeddingNamesFile << "0 {} 0 0 0 0"<<endl;
        }
		
		summaryFile << "***************************************************" << endl;
		summaryFile << "An analysis of the abstract graph: " << graphName << endl;
		summaryFile << "***************************************************" << endl;
		summaryFile << "There are --> "<< numToroidalRotationSchemes <<" <-- labeled and oriented embeddings on a topological torus." << endl;
		summaryFile << "These embeddings have --> " << faceTypeCount << " <-- different face degree types." << endl;
		summaryFile << "These reduce to --> " << numberOfInequivalentEmbedding << " <-- unlabeled and unoriented embeddings." << endl;
		summaryFile << "Of the unlabeled and unoriented embedding --> " << totalNumberOfFinalFaceDegreeTypes
		<< " <-- are NON-ELIMINATABLE using the forbidden face degree patterns" << endl;
		summaryFile << "and --> "<< (numberOfInequivalentEmbedding - totalNumberOfFinalFaceDegreeTypes) << " <-- are eliminatable using the forbidden face degree patterns." << endl;
		summaryFile << "***************************************************" << endl;
		summaryFile << endl;
		
		for(int i = 0; i < faceTypeCount; ++i){
			summaryFile << "************************************ Version "<< i+1 << " - Face Type: [ ";
			for(int j = 0; j < numberOfFaces;++j){
				summaryFile << faceTypes[i][j] << " ";
			}
			summaryFile << "] Total: " << numIneqEmbInFaceType[i] <<" ************************************" << endl;
			
			summaryFile << "Inequivalent embeddings of this face type which are NOT face pattern eliminatable: "
			<< numberOfFinalFaceDegreeTypes[i] << endl;
			summaryFile << "Inequivalent embedding of this face type which ARE face degree eliminatable: " <<
			(numIneqEmbInFaceType[i]-numberOfFinalFaceDegreeTypes[i]) << endl;
			summaryFile << endl;
			
			//a variable for naming the rotation schemes in this facetype
			int rotationSchemeCount = 1;
			
			summaryFile << "----- NON-ELIMINATABLE -----"<< endl;
			//First sort through the rotation schemes that are NOT eliminatable
			for(int j = 0; j < numIneqEmbInFaceType[i];++j){
				//finalRotationSchemeInfo[i][j][0]==1 implies all vertices do not have a forbidden face pattern
				if(finalRotationSchemeInfo[i][j][0] == 1){
					summaryFile << graphName << "_T" << i+1 << "_"<< rotationSchemeCount <<": ";
					
					embeddingNamesFile << graphName << "_T" << i+1 << "_"<< rotationSchemeCount << " ";
					
					torusEmbeddingFile << "$" << endl;
					torusEmbeddingFile << "&TorusMap" << endl;
					torusEmbeddingFile << graphName << "_T" << i+1 << "_"<< rotationSchemeCount << endl;
					if (fakeVertex>numberOfVertices) {
						torusEmbeddingFile << numberOfVertices << endl;
					} else {
						torusEmbeddingFile << fakeVertex << endl;
					};
					torusEmbeddingFile << "435 743 59 509" << endl;
					rotationSchemeCount++;
					
					summaryFile << "{";
					embeddingNamesFile << "{";
					for(int k = 0; k < numberOfVertices; ++k){
						// don't output a line for fakeVertices
						if (k>=fakeVertex) {
							break;
						}
						
						summaryFile << "{";
						embeddingNamesFile << "{";
						torusEmbeddingFile << "-" << k+1 << " ";
						// output the rotationScheme NOT in cartesian coordinates (i.e. output the cycle of neighboring vertices at each vertex)
						//first find a vertex that is not mapped to itself under the rotationScheme, call it startVertex
						int startVertex = 0;
						int writeStartVertex = 0; //this is the value that is written to the file when dealing with a mulitgraph
						for(int l = 0; l < numberOfVertices; ++l){
							if (not(sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][k][l]==l)){
								startVertex = l;
								writeStartVertex = l;
								// make sure that write start vertex is not a fake vertex
								if(writeStartVertex >= fakeVertex) {
									writeStartVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][writeStartVertex][k];
								};
								//only need this if we are working on a loop
								if(writeStartVertex >= fakeVertex){
									writeStartVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][writeStartVertex][startVertex];
								};
								break;
							}
						}
						
						
						
						//output the starting vertex (add one so that we don't have a zeroth vertex - in the G&G output file only - torusEmbeddingFile)
						summaryFile << writeStartVertex << ",";
						embeddingNamesFile << writeStartVertex << ",";
						torusEmbeddingFile << writeStartVertex+1 << " [0 " << tempGrphAdjMatrix[k][startVertex] <<"] ";
						
						// compute the next vertex in the rotation at vertex k (we know that this is not startVertex)
						int nextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][k][startVertex];
						// compute the next vertex to write in the rotation scheme to file
						int writeNextVertex = nextVertex;
						//make sure it isn't fake
						if (writeNextVertex>=fakeVertex) {
							writeNextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][writeNextVertex][k];
						};
						//only need this if we are working on a loop
						if(writeNextVertex >= fakeVertex){
							writeNextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][writeNextVertex][nextVertex];
						};
						
						//trace the neighbors of vertex k, outputing them until we return to the start vertex
						while (nextVertex!=startVertex) {
							summaryFile << writeNextVertex << ",";
							embeddingNamesFile << writeNextVertex << ",";
							torusEmbeddingFile << writeNextVertex+1 << " [0 " << tempGrphAdjMatrix[k][nextVertex] <<"] ";
							nextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][k][nextVertex];
							writeNextVertex = nextVertex;
							//make sure it isn't fake
							if (writeNextVertex>=fakeVertex) {
								writeNextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][writeNextVertex][k];
							};
							//only need this if we are working on a loop
							if(writeNextVertex >= fakeVertex){
								writeNextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][writeNextVertex][nextVertex];
							};
						}
						//find the end of the summaryFile and step the put pointer back a character so that the last comma is overwritten
						pos=summaryFile.tellp();
						summaryFile.seekp (pos-1);
						summaryFile << "},";
						
						//find the end of the file and step the put pointer back a character so that the last comma is overwritten
						pos=embeddingNamesFile.tellp();
						embeddingNamesFile.seekp (pos-1);
						embeddingNamesFile << "},";
						
						torusEmbeddingFile << endl;
					}
					//find the end of the summaryFile and step the put pointer back a character so that the last comma is overwritten
					pos=summaryFile.tellp();
					summaryFile.seekp (pos-1);
					summaryFile << "}" << endl;
					
					//find the end of the file and step the put pointer back a character so that the last comma is overwritten
					pos=embeddingNamesFile.tellp();
					embeddingNamesFile.seekp (pos-1);
					embeddingNamesFile << "} ";
					
					torusEmbeddingFile << "0" << endl;
					torusEmbeddingFile << endl;
					
					summaryFile << "   Vertices Face Pattern:  {";
					embeddingNamesFile << "{";
					for(int k = 0; k < numberOfVertices; ++k){
						// don't output a line for fakeVertices
						if (k>=fakeVertex) {
							break;
						}						
						summaryFile << "{";
						embeddingNamesFile << "{";
						for(int l = 0; l < numOfFacesAdjacentToVertex[i][j][k]; ++l){
							summaryFile << adjacentFacesDegrees[i][j][k][l] << ",";
							embeddingNamesFile << adjacentFacesDegrees[i][j][k][l] << ",";
						}
						//find the end of the file and step the put pointer back a character so that the last comma is overwritten
						pos=embeddingNamesFile.tellp();
						embeddingNamesFile.seekp (pos-1);
						embeddingNamesFile << "},";
						
						//find the end of the summaryFile and step the put pointer back a character so that the last comma is overwritten
						pos=summaryFile.tellp();
						summaryFile.seekp (pos-1);
						summaryFile << "},";
					}
					
					//find the end of the file and step the put pointer back a character so that the last comma is overwritten
					pos=embeddingNamesFile.tellp();
					embeddingNamesFile.seekp (pos-1);
					embeddingNamesFile << "}"<< endl;
					
					//find the end of the summaryFile and step the put pointer back a character so that the last comma is overwritten
					pos=summaryFile.tellp();
					summaryFile.seekp (pos-1);
					summaryFile << "}";
					summaryFile << endl;
					summaryFile<<" " << endl;
				}
			}
			
			summaryFile << "----- ELIMINATABLE -----"<< endl;
			
			//First sort through the rotation schemes that are eliminatable, output the offending vertex (numbered 1 to numberOfVertices
			// so that there is no vertex 0, just like the rotation schemes in cycle notation) also output the face pattern
			// around that vertex and the type into which it falls.
			for(int j = 0; j < numIneqEmbInFaceType[i];++j){
				//finalRotationSchemeInfo[i][j][0] ==0 implies a vertex has a forbidden face pattern
				if(finalRotationSchemeInfo[i][j][0] == 0){
					summaryFile << graphName << "_T" << i+1 << "_"<< rotationSchemeCount <<": ";
					
					embeddingNamesForbiddenFile << graphName << "_T" << i+1 << "_"<< rotationSchemeCount << " ";
					
					torusEmbeddingForbiddenFile << "$" << endl;
					torusEmbeddingForbiddenFile << "&TorusMap" << endl;
					torusEmbeddingForbiddenFile << graphName << "_T" << i+1 << "_"<< rotationSchemeCount << endl;
					if (fakeVertex>numberOfVertices) {
						torusEmbeddingForbiddenFile << numberOfVertices << endl;
					} else {
						torusEmbeddingForbiddenFile << fakeVertex << endl;
					};					
					torusEmbeddingForbiddenFile << "435 743 59 509" << endl;
					rotationSchemeCount++;
					
					summaryFile << "{";
					embeddingNamesForbiddenFile << "{";
					for(int k = 0; k < numberOfVertices; ++k){
						//don't output any fake vertices
						if (k>=fakeVertex) {
							break;
						}
						
						summaryFile << "{";
						embeddingNamesForbiddenFile << "{";
						torusEmbeddingForbiddenFile << "-" << k+1 << " ";
						
						// output the rotationScheme NOT in cartesian coordinates (i.e. output the cycle of neighboring vertices at each vertex)
						//first find a vertex that is not mapped to itself under the rotationScheme, call it startVertex
						int startVertex = 0; 
						int writeStartVertex = 0; //this is the value that is written to the file when dealing with a mulitgraph
						for(int l = 0; l < numberOfVertices; ++l){
							if (not(sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][k][l]==l)){
								startVertex = l;
								writeStartVertex = l;
								// make sure that write start vertex is not a fake vertex
								if(writeStartVertex >= fakeVertex) {
									writeStartVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][writeStartVertex][k];
								};
								//only need this if we are working on a loop
								if(writeStartVertex >= fakeVertex){
									writeStartVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][writeStartVertex][startVertex];
								};
								break;
							}
						}
						
						//output the starting vertex (add one so that we don't have a zeroth vertex for the output to G&G only - torusEmbeddingForbiddenFile)
						summaryFile << writeStartVertex << ",";
						embeddingNamesForbiddenFile << writeStartVertex << ",";
						torusEmbeddingForbiddenFile << writeStartVertex+1 << " [0 " << tempGrphAdjMatrix[k][startVertex] <<"] ";
						
						// compute the next vertex in the rotation at vertex k (we know that this is not startVertex)
						int nextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][k][startVertex];
						// compute the next vertex to write in the rotation scheme to file
						int writeNextVertex = nextVertex;
						//make sure it isn't fake
						if (writeNextVertex>=fakeVertex) {
							writeNextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][writeNextVertex][k];
						};
						//only need this if we are working on a loop
						if(writeNextVertex >= fakeVertex){
							writeNextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][writeNextVertex][nextVertex];
						};
						
						//trace the neighbors of vertex k, outputing them until we return to the start vertex
						while (nextVertex!=startVertex) {
							summaryFile << writeNextVertex << ",";
							embeddingNamesForbiddenFile << writeNextVertex << ",";
							torusEmbeddingForbiddenFile << writeNextVertex+1 << " [0 " << tempGrphAdjMatrix[k][nextVertex] <<"] ";
							nextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][k][nextVertex];
							writeNextVertex = nextVertex;
							//make sure it isn't fake
							if (writeNextVertex>=fakeVertex) {
								writeNextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][writeNextVertex][k];
							};
							//only need this if we are working on a loop
							if(writeNextVertex >= fakeVertex){
								writeNextVertex = sortedToroidalRotationSchemes[i][indexOfInqInSortedToroidalRotationSchemes[i][j]][writeNextVertex][nextVertex];
							};
						}
						
						//find the end of the summaryFile and step the put pointer back a character so that the last comma is overwritten
						pos=summaryFile.tellp();
						summaryFile.seekp (pos-1);
						summaryFile << "},";
						
						//find the end of the file and step the put pointer back a character so that the last comma is overwritten
						pos=embeddingNamesForbiddenFile.tellp();
						embeddingNamesForbiddenFile.seekp (pos-1);
						embeddingNamesForbiddenFile << "},";
						
						torusEmbeddingForbiddenFile << endl;
					}
					
					//find the end of the summaryFile and step the put pointer back a character so that the last comma is overwritten
					pos=summaryFile.tellp();
					summaryFile.seekp (pos-1);
					summaryFile << "}" << endl;
					
					//find the end of the file and step the put pointer back a character so that the last comma is overwritten
					pos=embeddingNamesForbiddenFile.tellp();
					embeddingNamesForbiddenFile.seekp (pos-1);
					embeddingNamesForbiddenFile << "} ";
					
					summaryFile << "   Vertices Face Pattern:  {";
					embeddingNamesForbiddenFile << "{";
					for(int k = 0; k < numberOfVertices; ++k){
						// don't output a line for fakeVertices
						if (k>=fakeVertex) {
							break;
						}
						
						summaryFile << "{";
						embeddingNamesForbiddenFile << "{";
						for(int l = 0; l < numOfFacesAdjacentToVertex[i][j][k]; ++l){
							summaryFile << adjacentFacesDegrees[i][j][k][l] << ",";
							embeddingNamesForbiddenFile << adjacentFacesDegrees[i][j][k][l] << ",";
						}
						//find the end of the file and step the put pointer back a character so that the last comma is overwritten
						pos=embeddingNamesForbiddenFile.tellp();
						embeddingNamesForbiddenFile.seekp (pos-1);
						embeddingNamesForbiddenFile << "},";
						
						//find the end of the summaryFile and step the put pointer back a character so that the last comma is overwritten
						pos=summaryFile.tellp();
						summaryFile.seekp (pos-1);
						summaryFile << "},";
					}
					//find the end of the file and step the put pointer back a character so that the last comma is overwritten
					pos=embeddingNamesForbiddenFile.tellp();
					embeddingNamesForbiddenFile.seekp (pos-1);
					embeddingNamesForbiddenFile << "} {";
					
					//find the end of the summaryFile and step the put pointer back a character so that the last comma is overwritten
					pos=summaryFile.tellp();
					summaryFile.seekp (pos-1);
					summaryFile << "}" << endl;
					
					summaryFile << "   Face pattern: [ ";
					for(int l = 0; l < numOfFacesAdjacentToVertex[i][j][finalRotationSchemeInfo[i][j][2]]; ++l){
						summaryFile << adjacentFacesDegrees[i][j][finalRotationSchemeInfo[i][j][2]][l] << ",";
						if (finalRotationSchemeInfo[i][j][1] < 8) {
							embeddingNamesForbiddenFile << adjacentFacesDegrees[i][j][finalRotationSchemeInfo[i][j][2]][l] << ",";
						}
					}
				
						//find the end of the file and step the put pointer back a character so that the last comma is overwritten
						pos=embeddingNamesForbiddenFile.tellp();
						embeddingNamesForbiddenFile.seekp (pos-1);
					if (finalRotationSchemeInfo[i][j][1] < 8) {
						embeddingNamesForbiddenFile << "} ";
					} else {
						embeddingNamesForbiddenFile << forbiddenAdjacentFacesDegrees[finalRotationSchemeInfo[i][j][1]-1] << " ";
					}

					
					summaryFile << "] around Vertex --> " << finalRotationSchemeInfo[i][j][2]
					<< " <-- which is of the forbidden type " << forbiddenAdjacentFacesDegrees[finalRotationSchemeInfo[i][j][1]-1] << endl;
					embeddingNamesForbiddenFile << finalRotationSchemeInfo[i][j][2] << endl;
					summaryFile << endl;
					torusEmbeddingForbiddenFile << "0" << endl;
					torusEmbeddingForbiddenFile << endl;
				}
			}
			summaryFile << endl;
		}
		
		summaryFile.close();
		embeddingNamesFile.close();
		embeddingNamesForbiddenFile.close();
		torusEmbeddingForbiddenFile.close();
		torusEmbeddingFile.close();
		/***************************************************************************
		 ****************************************************************************
		 *****End of Export Resutls to  files***********************************************
		 ****************************************************************************
		 ***************************************************************************/
	//// Exit the program!
	exit(0);
}
